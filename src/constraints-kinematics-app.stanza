defpackage constraints-kinematics-app :
  import core
  import math
  import collections
  import utils/file-system
  import utils/math
  import utils/rnd
  import utils/seqable
  import geom/vec
  import geom/mat
  import geom/angle
  import geom/shape
  import geom/bounded
  import geom/poseable
  import geom/line-segment
  import geom/polygon
  import geom/polyline
  import geom/line-loop
  import geom/box
  import geom/polyhedron
  import geom/polyhedra
  import gui/props
  import gui/lay
  import gui/viz
  import gfx/gl
  import gfx/glfw
  import gfx/font
  import geom/gfx
  import gfx/drawing
  import calculus
  import constraints
  import constraints-paths
  import constraints-viz

defstruct LinkSpec :
  name : Symbol
  len : Float
  ; start : Symbol
  ; end : Symbol

; defn vertices (spec:LinkSpec) -> Tuple<Symbol> :
;   [start(spec), end(spec)]
; 
; defn connected? (spec:LinkSpec, vertex:Symbol) -> True|False :
;   start(spec) == vertex or end(spec) == vertex
; 
; defn other (spec:LinkSpec, vertex:Symbol) -> Symbol :
;   start(spec) when end(spec) == vertex else end(spec)

; defenum LinkSide :
;   LinkStart
;   LinkEnd
; 
; defstruct LinkVertexSpec :
;   link : Symbol
;   side : LinkSide

defenum JointKind :
  HingeJoint
  RotaryJoint

defstruct JointSpec :
  name : Symbol
  ; axis : Int
  ; limits : Box1f
  kind: JointKind
  link0 : Symbol
  link1 : Symbol

defn connected? (spec:JointSpec, link:Symbol) -> True|False :
  link0(spec) == link or link1(spec) == link

defn other (spec:JointSpec, link:Symbol) -> Symbol :
  link0(spec) when link1(spec) == link else link1(spec)

defmulti joint-angle (kind:JointKind, l0:Link, l1:Link) -> Angle 
defmulti joint-cost (kind:JointKind, l0:Link, l1:Link) -> Exp

defstruct KinematicsSpec :
;  root : Symbol
  links : Tuple<LinkSpec>
  joints : Tuple<JointSpec>

; defn vertices (spec:KinematicsSpec) -> Seqable<Symbol> :
;   unique $ for link in links(spec) seq-cat : [start(link), end(link)]
; 
; defn links-of (spec:KinematicsSpec, vertex:Symbol) -> Seqable<LinkSpec> :
;   for link in links(spec) filter : connected?(link, vertex)

defstruct Link <: Module :
  id : Symbol with: (as-method => true)
  init-len : Float
  rnd-radius : Float with: (default => 1.0f)
  len : Const with: (init => Const(init-len))
  a : Vertex with: (init => Vertex(`a, false, V3f( -5.0f, 0.0f) + rnd-radius * V3f(rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f)), false))
  b : Vertex with: (init => Vertex(`b, false, V3f(  5.0f, 0.0f) + rnd-radius * V3f(rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f)), false))
  c : Vertex with: (init => Vertex(`c, true,  V3f( -5.0f, 0.0f, 5.0f) + rnd-radius * V3f(rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f)), false))
  y : Edge with: (init => Edge(`y, a, b))
  z : Edge with: (init => Edge(`z, a, c, true, false))
  ang : Angle with: (init => ConnectedAngle(`abc, y, z, true))
  entities : Tuple<Entity> with: (as-method => true, init => [a, b, c, y, z, ang])
  cost : Exp with: (as-method => true, init =>
    EdgeLengthConstraint( exp(y), len) + OrthogonalConstraint(exp(y), exp(z))) ;AngleConstraint(ang, Const(PI-F / 2.0f)))

defmethod joint-angle (kind:HingeJoint, l0:Link, l1:Link) : 
  Angle(`ang, b(l0), a(l0), a(l1), b(l1), true)

defmethod joint-cost (kind:HingeJoint, l0:Link, l1:Link) :
  ; OrthogonalConstraint(exp(z(l0)), exp(z(l1)))
  ParallelConstraint(exp(z(l0)), exp(z(l1)))

defmethod joint-angle (kind:RotaryJoint, l0:Link, l1:Link) :
  Angle(`ang, z(l0), z(l1), true)

defmethod joint-cost (kind:RotaryJoint, l0:Link, l1:Link) :
  ParallelConstraint(exp(y(l0)), exp(y(l1)))

defstruct Joint <: Module :
  id : Symbol with: (as-method => true)
  kind : JointKind
  l0 : Link
  l1 : Link
  ang : Angle with: (init => joint-angle(kind, l0, l1))
  entities : Tuple<Entity> with: (as-method => true, init => [ang])
  cost : Exp with: (as-method => true, init =>
    joint-cost(kind, l0, l1) +
    SameVertexConstraint( [ b(l0), a(l1) ])
    )

defstruct KinematicsBody <: Module :
  id : Symbol with: (as-method => true)
  specs : KinematicsSpec
  link-table : HashTable<Symbol,Link> with: (init => HashTable<Symbol,Link>())
  links : Tuple<Link> with: (init => to-tuple $ for spec in links(specs) seq :
    val link = make-instance(name(spec), Link{_, len(spec)})
    println("link %_" % [name(spec)])
    link-table[name(spec)] = link
    link)
  joints : Tuple<Joint> with: (init => to-tuple $ for spec in joints(specs) seq :
    val l0 = link-table[link0(spec)]
    val l1 = link-table[link1(spec)]
    println("joint %_" % [name(spec)])
    make-instance(name(spec), Joint{_, kind(spec), l0, l1}))
  entities : Tuple<Entity> with: (as-method => true, init => to-tuple $ cat(links, joints))
  cost : Exp with: (as-method => true, init => Const(0.0f))

defn joints (spec:KinematicsSpec, link:Symbol) -> Seqable<JointSpec> :
  for joint in joints(spec) filter : connected?(joint, link)

;;; KINEMATICS EXP

defstruct LinkExpSpec :
  name : Symbol
  mass : Float with: (default => 1.0f)
  node0 : Symbol
  node1 : Symbol
  len : Float
with:
  printer => true

defstruct JointExpSpec :
  name : Symbol
  mass : Float with: (default => 1.0f)
  axis : Int
  limits : Box1f
  link0 : Symbol
  link1 : Symbol
with:
  printer => true

val default-limits = Box1f((- PI-F), PI-F)
val default-z-limits = Box1f((- PI-F), PI-F)
val default-x-limits = Box1f(-0.5f * PI-F, 0.5f * PI-F)
; val default-limits = Box1f(0.0f * PI-F, 0.0f * PI-F)

defn connected? (spec:LinkExpSpec, node:Symbol) -> True|False :
  node0(spec) == node or node1(spec) == node

defn other (spec:LinkExpSpec, node:Symbol) -> Symbol :
  node0(spec) when node1(spec) == node else node1(spec)

defn connected? (spec:JointExpSpec, link:Symbol) -> True|False :
  link0(spec) == link or link1(spec) == link

defn other (spec:JointExpSpec, link:Symbol) -> Symbol :
  link0(spec) when link1(spec) == link else link1(spec)

defstruct KinematicsExpSpec :
  root : Symbol
  links : Tuple<LinkExpSpec>
  joints : Tuple<JointExpSpec>
  mid-threshold : Float
with:
  printer => true

defn KinematicsExpSpec (root:Symbol, i-links-and-joints:Seqable<LinkExpSpec|JointExpSpec>, mid-threshold:Float) -> KinematicsExpSpec :
  val lj = to-tuple $ i-links-and-joints
  KinematicsExpSpec(
    root,
    to-tuple $ filter-by<LinkExpSpec>(lj), 
    to-tuple $ filter-by<JointExpSpec>(lj),
    mid-threshold)

defn KinematicsExpSpec (root:Symbol, i-links-and-joints:Seqable<LinkExpSpec|JointExpSpec>) -> KinematicsExpSpec :
  KinematicsExpSpec(root, i-links-and-joints, 1.0e6f)

defn links-with-node (spec:KinematicsExpSpec, node:Symbol) -> Seq<LinkExpSpec> :
  for link in links(spec) filter : connected?(link, node)    

defn mov-y-mat-exp (del:Exp) -> MatExp :
  mov-mat-exp(Vec3Exp(Const(0.0f), del, Const(0.0f)))

defstruct LinkExp <: Entity :
  id : Symbol with: (as-method => true)
  idx : Int
  len : Float
  edge : Edge         ; points to two 
  axis : Int
  angle : SymVar
  limits : Box1f
  pose : SimplePoseExp
  ; local-mat : MatExp
  global-mat : Mat
  joint-mass : Float
  link-mass : Float
  link-parents : Tuple<LinkExp>
  mid-vertices : Tuple<Vertex>
  torque : ExpVar
with:
  printer => true

; TODO: MOVE
public defn sum (xs:Seqable<V3f>) -> V3f :
  reduce(fn (a:V3f, b:V3f) : a + b, xyz(0.0f), xs)

defn xz (v:V3f) -> V2f :
  V2f(x(v), z(v))

val GRAVITY = 9.81f

val viz-torques? = true
val viz-limits? = false

defmethod draw (e:LinkExp, size:Float) :
  val max-h = 239.0f
  var tx:? = 0
  val [r, g, b] = 
    if viz-torques? :
      val sum-torques = sum $ for link in link-parents(e) seq :
        val d = (pos(v0(edge(link))) - pos(v0(edge(e))))
        joint-mass(link) * d
      val torque = GRAVITY * 0.01f * magnitude(xz(sum-torques))
      val h = max-h - (min(torque / 2.0f, 1.0f) * max-h)
      ; println("T %_ H %_" % [torque, h])
      hsv-to-rgb(h, 1.0f, 1.0f)
    else if viz-limits? :
      val mx = hi(limits(e))
      val a = x(angle(e))
      val d = min(abs(a - lo(limits(e))), abs(a - hi(limits(e))))
      tx = d
      val h = (d / mx) * 239.0f
      hsv-to-rgb(h, 1.0f, 1.0f)
    else :
      [1.0f, 1.0f, 1.0f]

  ; gl-color3f(1.0f, 1.0f, 1.0f)
  gl-color3f(r, g, b)
  gl-push-matrix()
  ; println("%_" % [value(global-mat(e))])
  gl-mult-matrix(value(global-mat(e)))
  ; gl-mult-matrix(id-mat44f())
  gl-translatef(0.0f, -0.5f * len(e), 0.0f)
  draw-rect3(1.5f, len(e), 3.0f)
  draw-text(20.0f * size, 5.0f * size, *font*, to-string $ tx)
  gl-pop-matrix()

  if top-show-torques?:
    ; println("LINK %_ %_" % [id(e), xz(pos(v0(edge(e))))])
    val res = sum $ for link in link-parents(e) seq :
      val d = (pos(v0(edge(link))) - pos(v0(edge(e))))
      joint-mass(link) * d
  ;   println("  %_ M %_ XY %_ -> %_ %_" % [name(link), joint-mass(link), xz(pos(v0(edge(link)))), xz(d), magnitude(xy(d))])
  ; println("  RES %_ MAG %_" % [xz(res), GRAVITY * 0.03f * magnitude(xyz(xz(res)))])
    println("LINK %_ %_" % [id(e), GRAVITY * 0.01f * magnitude(xz(res))])

defmethod vars (e:LinkExp) -> Seqable<AnyVar> :
  cat(vars(edge(e)), [angle(e), torque(e)])

defn calc-torque (links:HashTable<Symbol,LinkExp>, src:Vertex, parents:Tuple<Symbol>) -> Exp :
  ; val cog = sum $ for link in seq({ get(links, _) }, parents) seq :
  ;   Const(joint-mass(link)) * xy(exp(v0(edge(link))))
  ; Const(GRAVITY * 0.01f) * magnitude(cog - Const(to-float(length(parents))) * xy(exp(src)))
  val cog = sum $ for link in seq({ get(links, _) }, parents) seq :
    ; Const(joint-mass(link)) * (xy(exp(v0(edge(link)))) - xy(exp(src)))
    Const(joint-mass(link)) * (xz(exp(v0(edge(link)))) - xz(exp(src)))
  Const(GRAVITY * 0.01f) * magnitude2(cog)
  ; Const(GRAVITY * 0.01f) * magnitude(cog)

defn init-edges (id:Symbol, spec:KinematicsExpSpec, vertices:HashTable<Symbol,Vertex>, mid-vertices:HashTable<Symbol,Vertex>) -> HashTable<Symbol,LinkExp> :
  val link-specs = to-hashtable<Symbol, LinkExpSpec> $
    for l in links(spec) seq : name(l) => l
  val joint-specs = to-hashtable<[Symbol,Symbol], JointExpSpec> $
    for j in joints(spec) seq-cat : [[link0(j),link1(j)] => j, [link1(j),link0(j)] => j]
  val link-nbrs = HashTable<Symbol, List<Symbol>>(List())
  for joint in joints(spec) do :
    link-nbrs[link0(joint)] = cons(link1(joint), link-nbrs[link0(joint)])
    link-nbrs[link1(joint)] = cons(link0(joint), link-nbrs[link1(joint)])

  ; println(spec)
  ; println(to-tuple $ link-nbrs)

  val visited-links? = HashSet<Symbol>()
  val origin = Vertex(root(spec), false, V3f(0.0f, -36.0f, 0.0f), false) ; true
  vertices[root(spec)] = origin
  val link-exps = HashTable<Symbol,LinkExp>()
  var joint-idx:Int = 0
  val res = to-tuple $ let loop (from-link-name:False|Symbol = false, from-vertex:Vertex = origin, from-global-mat:MatExp = mov-mat-exp(exp(origin))) :
    ; println("FROM-LINK %_ FROM-VERTEX %_" % [from-link-name, name(from-vertex)])
    for to-link-spec in to-tuple(links-with-node(spec, name(from-vertex))) seq-cat :
      val to-link-name = name(to-link-spec)
      ; println("CONSIDERING %_" % [to-link-name])
      if not visited-links?[to-link-name] :
        ; println(">>> WALKING LINK %_" % [to-link-name])
        add(visited-links?, to-link-name)
        val [axis, angle, limits, joint-mass] =
          match(from-link-name:Symbol) :
            val joint-spec = joint-specs[[from-link-name, to-link-name]]
            val angle-value = 0.25f * rnd(limits(joint-spec))
            ; println("%_ %_ = %_" % [name(joint-spec), limits(joint-spec), radians-to-degrees(angle-value)])
            val angle = SymVar(name(joint-spec), angle-value, limits(joint-spec))
            if lo(limits(joint-spec)) != hi(limits(joint-spec)) :
              set-idx(angle, joint-idx)
              joint-idx = joint-idx + 1
            [axis(joint-spec), angle, limits(joint-spec), mass(joint-spec)]
          else :
            [2, SymVar(`root, 0.0f, false), Box1f(0.0f, 0.0f), 0.0f]
        val pose = SimplePoseExp(Vec3Exp(Const(0.0f), Const(len(to-link-spec)), Const(0.0f)), axis, exp(angle))
        val to-local-mat = to-mat-exp(pose)
        val to-global-mat = to-local-mat * from-global-mat
        val to-global-mat-vars = Mat(to-link-name, to-global-mat)
        val to-vertex-name = other(to-link-spec, name(from-vertex))
        val to-vertex = Vertex(to-vertex-name, to-global-mat * Const(V3f(0.0f, 0.0f, 0.0f)))
        vertices[to-vertex-name] = to-vertex

        val mid-verts =
          if len(to-link-spec) > mid-threshold(spec) :
            val num = 2
            to-tuple $ for i in 0 to num seq :
              val mid-vertex-name = symbol-join $ [name(from-vertex), "-mid", i, "-" name(to-vertex) ]
              val off = to-float(i + 1) / to-float(num + 1)
              val mid-vertex = Vertex(mid-vertex-name, Const(off) * exp(from-vertex) + Const(1.0f - off) * exp(to-vertex))
              mid-vertices[mid-vertex-name] = mid-vertex
              mid-vertex
          else :
            []

        val edge = Edge(to-link-name, from-vertex, to-vertex)
        val parents = to-tuple $ loop(to-link-name, to-vertex, to-global-mat)
        val torque = calc-torque(link-exps, v0(edge), parents)
        val to-link-exp = LinkExp(to-link-name, length(link-exps), len(to-link-spec), edge, axis, angle, limits, pose, to-global-mat-vars,
                                  joint-mass, mass(to-link-spec),
                                  to-tuple $ seq({ link-exps[ _ ] }, parents),
                                  mid-verts, 
                                  ExpVar(symbol-join([to-vertex-name, "-torque"]), torque)) ; to-local-mat, 
        link-exps[to-link-name] = to-link-exp
        cat([to-link-name], parents)
      else :
        []
        
        ; println("<<< WALKED LINK %_" % [to-link-name])

  ; println(to-tuple $ link-exps)
  ; println(to-tuple $ vertices)

  ; println(to-tuple $ res)
  ; println(to-tuple $ link-exps)
  link-exps

defn vertex-to-sphere-name (n:Symbol) -> Symbol :
  symbol-join $ [n, "-sphere"]
defn vertex-to-sphere-name (v:Vertex) : vertex-to-sphere-name(id(v))
  

defn vertex-collision-excludes (links:Tuple<LinkExp>) -> HashTable<Symbol,List<Symbol>> :
  val excludes = HashTable<Symbol,List<Symbol>>(List())
  val nbr-links =
    to-hashtable<Symbol,Tuple<LinkExp>> $ for l1 in links seq : id(l1) =>
      to-tuple $ for l2 in links seq-cat :
        [ l2 ] when (abs(idx(l2) - idx(l1)) < 2) else []
  for l1 in links do :
    println("  LINK1 %_ %_" % [id(l1), idx(l1)])
    for l2 in nbr-links[id(l1)] do :
      println("    LINK2 %_ %_" % [id(l2), idx(l2)])
      defn verts-of (l:LinkExp) : cat-all $ [[ v0(edge(l)) ] [ v1(edge(l)) ], mid-vertices(l) ]
      defn unique-cons (a:Symbol, l:List<Symbol>) :
        l when contains?(l, a) else cons(a, l)
      for v1 in verts-of(l1) do :
        for v2 in verts-of(l2) do :
          excludes[id(v1)] = unique-cons(id(v2), excludes[id(v1)])
          excludes[id(v2)] = unique-cons(id(v1), excludes[id(v2)])

  val num-excludes = length $ to-tuple $ for exc in values(excludes) seq-cat : exc
  println("TOT EXCLUDES %_" % [num-excludes])
  excludes

defstruct KinematicsExpBody <: Module :
  id : Symbol with: (as-method => true)
  specs : KinematicsExpSpec
  sphere-radius : ExpVar with: (init => ExpVar(symbol-join $ [id, "-sphere-radius"], Const(3.0f)))
  mid-vertex-table : HashTable<Symbol,Vertex> with: (init => HashTable<Symbol,Vertex>())
  vertex-table : HashTable<Symbol,Vertex> with: (init => HashTable<Symbol,Vertex>())
  link-table : HashTable<Symbol,LinkExp> with: (init => init-edges(id, specs, vertex-table, mid-vertex-table))
  spheres : Tuple<Sphere> with: (init =>
    to-tuple $ for v in cat(values(vertex-table), values(mid-vertex-table)) seq :
                 Sphere(vertex-to-sphere-name(v), v, sphere-radius))
  entities : Tuple<Entity> with: (as-method => true, init => 
    to-tuple $ cat-all $ [values(vertex-table), values(mid-vertex-table), spheres
                          for l in values(link-table) seq-cat : [l, angle(l), edge(l), global-mat(l)]])
  cost : Exp with: (as-method => true, init => Const(0.0f))
  vertex-collision-excludes : HashTable<Symbol,List<Symbol>> with: (init => vertex-collision-excludes(to-tuple $ values(link-table)))

defstruct KinematicsExpBody2 <: Module :
  id : Symbol with: (as-method => true)
  len : Const with: (init => Const(5.0f))
  s : SymVar with: (init => SymVar(`s, PI-F / 4.0f))
  t : SymVar with: (init => SymVar(`t, PI-F / 2.0f))
  a : Vertex with: (init => Vertex(`a, false, V3f(0.0f, 0.0f, 0.0f), false))
  b : Vertex with: (init => Vertex(`b, exp(a) + len * Vec3Exp(cos(exp(s)), sin(exp(s)), Const(0.0f))))
  c : Vertex with: (init => Vertex(`c, exp(b) + len * Vec3Exp(cos(exp(t)), sin(exp(t)), Const(0.0f))))
  ab : Edge with: (init => Edge(`ab, a, b))
  bc : Edge with: (init => Edge(`bc, b, c))
  entities : Tuple<Entity> with: (as-method => true, init => [s, t, a, b, c, ab, bc])
  ; cost : Exp with: (as-method => true, init => SameVecConstraint([ exp(c) Vec3Exp(Const(-1.0f), Const(1.0f), Const(0.0f))]))
  ; cost : Exp with: (as-method => true, init => SameConstraint(exp(y(c)) Const(0.0f)))
  ; cost : Exp with: (as-method => true, init => SameConstraint(exp(x(c)) Const(-2.0f)))
  cost : Exp with: (as-method => true, init => Const(0.0f))

defn TimeKinematics (name:Symbol, radius:Float, time:SymVar) -> BindBody :
  val path = PolyLinePath(`path, time, mag(xyz(radius)) $ square-path, 4.0f)
  BindBody(`tkb, KinematicsExpBody2(`tab),
           fn (m) : []
           fn (m) : cat-all $ [ [ c(m) => exp(point(path)) ] ]
           to-tuple $ cat-all $ seq(vars, [path]))

defn MixCost (id:Symbol, n:Symbol, g:Float, e:Exp) -> MixCost :
  MixCost(add-suffix(full-name(id), n), g, e)

defn MixCost (id:Symbol, n:Symbol, e:Exp) -> MixCost :
  MixCost(id, n, 1.0f, e)

defn centering (m:KinematicsExpBody, do-center:(Tuple<Vec3Exp>, Vec3Exp) -> Exp, center:Vec3Exp) -> Exp :
  do-center(to-tuple $ seq(exp, values(vertex-table(m))), center)

defn centering (m:KinematicsExpBody) -> Exp :
  centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))

defn curl-angle (a:Exp) -> Exp :
  defn curl (a:Exp) : exp(Const(-1.0f) * a * a)
  Const(100.0f) * curl(Const(1.5f / PI-F) * a)

defn curl-angles (m:KinematicsExpBody) -> Exp :
  ; sum $ seq(fn (l) : curl-angle(angle(l)), for l in values(link-table(m)) filter : axis(l) == 2)
  sum $ seq(fn (l) : curl-angle(exp(angle(l))), values(link-table(m)))

defn limit-angle (a:Exp, ilim:Float) -> Exp :
  if ilim == 0.0f :
    Const(0.0f)
  else :
    val lim = 1.1f * ilim 
    defn limit* (a:Exp) : Const(1.0f) / (a * a)
    defn limit (a:Exp) : limit*(a / Const(lim)) - Const(1.0f)
    limit(a - Const(lim)) + limit(a + Const(lim))
    ; defn limit (a:Exp) : (exp(a * a) - Const(1.0f))
    ; defn limit (a:Exp) : (exp(a * a) - Const(1.0f))
    ; limit(Const(3.0f / PI-F) * a)
    ; limit(Const(1.0f / PI-F) * a)
    ; limit(Const(2.0f / PI-F) * a)

defn limit-angles (m:KinematicsExpBody) -> Exp :
  ; sum $ seq(fn (l) : limit-angle(angle(l)), for l in values(link-table(m)) filter : axis(l) == 2)
  sum $ seq(fn (l) : (println("%_ %_ %_" % [id(l), axis(l), limits(l)]), limit-angle(exp(angle(l)), hi(limits(l)))), values(link-table(m)))

defn straighten (m:KinematicsExpBody) -> Exp :
  ; sum $ seq(fn (l) : exp(angle(l)) * exp(angle(l)), for l in values(link-table(m)) filter : axis(l) == 2)
  sum $ seq(fn (l) : exp(angle(l)) * exp(angle(l)), values(link-table(m)))

defn fall (m:KinematicsExpBody, tips:Tuple<Symbol>, target:Float) -> Exp :
  ; sum $ seq(fn (l): sqerr(Const(target) - y(exp(v1(edge(l))))), values(link-table(m)))
  sum $ seq(fn (tip): sqerr(Const(target) - y(exp(vertex-table(m)[tip]))), tips)

defn above (m:KinematicsExpBody, tips:Tuple<Symbol>, target:Float) -> Exp :
  sum $ seq(fn (tip): logistic(Const(target) - y(exp(vertex-table(m)[tip]))), tips)

defn fall (m:KinematicsExpBody, tips:Tuple<Symbol>, target:V3f) -> Exp :
  ; sum $ seq(fn (l): (println(name(v1(edge(l)))), sqerr(Const(target) - exp(y(v1(edge(l)))))), values(link-table(m)))
  sum $ seq(fn (tip): SameConstraint(exp(vertex-table(m)[tip]), Const(target)), tips)

defn basing (m:KinematicsExpBody, origin:Float) -> Exp :
  Const(10.0f) * SameVecConstraint([exp(vertex-table(m)[root(specs(m))]) Const(V3f(0.0f, origin, 0.0f))])

defn repel (v1:Vec3Exp, v2:Vec3Exp, d:Exp) -> Exp :
  ; val x = distance2(v1, v2)
  ; d / x
  ; d * exp(Const(-1.0f) * x)
  val x = distance(v1, v2)
  d / pow(x - Const(6.0f), Const(2.0f))

defn repel (v1:Vertex, v2:Vertex, d:Exp) -> Exp :
  repel(exp(v1), exp(v2), d)

defn TimeExpKinematics (name:Symbol, time:SymVar, spec:KinematicsExpSpec, new-entities:Seqable<Entity>,
                        new-constraints:(KinematicsExpBody, HashTable<Symbol,Vertex>) -> Seqable<MixCost>) -> BindBody :
  val m = KinematicsExpBody(`main, spec)
  BindBody(name, m,
           new-constraints(m, vertex-table(m)),
           ; cat([ MixCost(name, `basing, basing(m, -36.0f))], new-constraints(m, vertex-table(m))),
           to-tuple $ cat-all $ seq(vars, new-entities), new-entities)

defn TimeExpKinematicsRepel (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ ],
    fn (m, verts) : [
      MixCost(name, `repel, repel(verts[left-tip], verts[right-tip], Const(2.0f))) ])

defn TimeExpKinematicsPath (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m)), MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

defn TimeExpKinematicsSimplePath (name:Symbol, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

defn all-repels (name:Symbol, verts:HashTable<Symbol, Vertex>, vertex-collision-excludes:HashTable<Symbol,List<Symbol>>) -> Seqable<MixCost> :
  if top-collision-detection? :
    val vert-names = to-tuple $ keys(verts)
    println("%_ VERTS %_" % [length(vert-names), vert-names])
    var num:Int = 0
    val tot = sum $ for i in 0 to length(verts) seq-cat :
      for j in (i + 1) to length(verts) seq-cat :
        if contains?(vertex-collision-excludes[vert-names[i]], vert-names[j]) :
          []
        else :
          num = num + 1
          [ repel(verts[vert-names[i]], verts[vert-names[j]], Const(100.0f)) ]
    println("NUM-REPELS = %_" % [num])
    [ MixCost(name, `repel, tot) ]
  else :
    []

; defn all-repels (name:Symbol, verts:HashTable<Symbol, Vertex>) -> Seqable<MixCost> :
;   if top-collision-detection? :
;     val vert-names = to-tuple $ keys(verts)
;     println(vert-names)
;     for i in 0 to length(verts) seq-cat :
;       for j in (i + 1) to length(verts) seq :
;         MixCost(name, symbol-join $ [`repel "-" i "-" j], repel(verts[vert-names[i]], verts[vert-names[j]], Const(8.0f)))
;   else :
;     []

defn all-gyrations (name:Symbol, ts:Seqable<Exp>, links:Seqable<LinkExp>) -> Seqable<MixCost> :
  for (link in links, t in ts, i in 0 to false) seq :
    MixCost(name, symbol-join $ [`gyrate "-" id(link)],
            SameConstraint(exp(angle(link)), Const(PI-F) * sin(t)))

defn TimeExpKinematicsTwoPaths (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
                                left-path:Path, left-tip:Symbol, right-path:Path, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ left-path, right-path ],
    fn (m, verts) :
      val vert-names = to-tuple $ keys(verts)
      cat-all $ [[
        MixCost(name, `centering, centering(m)),
        MixCost(name, `limit, limit-angles(m)),
        ; MixCost(name, `touch, Const(0.5f), DistanceConstraint(verts[right-tip], verts[left-tip], Const(1.0f)))
        MixCost(name, `left-path,  SameConstraint(exp(verts[left-tip]),  exp(point(left-path))))
        MixCost(name, `right-path, SameConstraint(exp(verts[right-tip]), exp(point(right-path))))
        ]
        all-repels(name, verts, vertex-collision-excludes(m))
      ]
)

defn test-joint (test-idx:Int, links:Seqable<LinkExp>) -> Exp :
  println("IDX %_" % [idx])
  sum $ for (link in links) seq-cat :
    val ang = angle(link)
    if dx-update?(ang) :
      val a = Const(PI-F / 8.0f) when (idx(ang) == test-idx) else Const(0.0f)
      println("  I %_ %_ A %_" % [idx(ang), id(ang), a])
      [ SameConstraint(exp(ang), a) ]
    else :
      []

defn all-gyrations (ts:Seqable<Exp>, links:Tuple<LinkExp>) -> Exp :
  sum $ for (link in links, t in ts, i in 0 to false) seq :
    SameConstraint(exp(angle(link)), Const(PI-F) * sin(t))

defn rnd-gyrations (t:Exp, links:Tuple<LinkExp>) -> Exp :
  val ts = for i in 0 to length(links) seq:
    t * Const(rnd(Box1f(0.25f, 2.0f))) + Const(rnd(Box1f(1.0f)))
  all-gyrations(ts, links)

defn wild-gyrations (t:Exp, links:Tuple<LinkExp>) -> Exp :
  val ts = for i in 0 to length(links) seq:
    (t + cos(t)) * Const(rnd(Box1f(0.25f, 2.0f))) + Const(rnd(Box1f(1.0f)))
  all-gyrations(ts, links)

defn inc-gyrations (t:Exp, links:Tuple<LinkExp>) -> Exp :
  val ts = for i in 0 to length(links) seq: t + Const(rnd(Box1f(1.0f)))
  all-gyrations(ts, links)

defn DOF (name:Symbol, time:SymVar, spec:KinematicsExpSpec,
          left-path1:Path, left-path2:Path, right-path1:Path, right-path2:Path) -> BindBody :
  val left-tip = `left-j4
  val right-tip = `right-j4
  val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
  val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
  val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
  val all-joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val knee = bottom-joints[2]
  val origin = `origin
  val target = SymVar(add-suffix(name, `target), 0.0f, false, false)
  val ground = -30.0f
  TimeExpKinematics(name, time, spec, [ time, target, left-path1, right-path1, left-path2, right-path2 ],
    fn (m, verts) :
      defn gyration-time (d:Float) : exp(time) * Const(2.0f * PI-F / d)
      val links = to-tuple $ values(link-table(m))
      cat-all $ [[
        MixCost(name, `centering-xyz, centering(m)),
        MixCost(name, `centering-xz, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
        MixCost(name, `left-trace, SameConstraint(exp(verts[right-tip]), Vec3Exp(x(exp(verts[left-tip])), exp(target), z(exp(verts[left-tip])))))
        MixCost(name, `left-ground, SameConstraint(y(exp(verts[left-tip])), Const(ground)))
        MixCost(name, `right-ground, SameConstraint(y(exp(verts[right-tip])), Const(ground)))
        MixCost(name, `limit, limit-angles(m)),
        MixCost(name, `bind, DistanceConstraint(exp(verts[right-tip]), exp(verts[left-tip]), exp(target)))
        MixCost(name, `origin-path2,  SameConstraint(exp(verts[origin]),  exp(point(left-path2))))
        MixCost(name, `left-path1,  SameConstraint(exp(verts[left-tip]),  exp(point(left-path1))))
        MixCost(name, `left-path2,  SameConstraint(exp(verts[left-tip]),  exp(point(left-path2))))
        MixCost(name, `right-path1, SameConstraint(exp(verts[right-tip]), exp(point(right-path1))))
        MixCost(name, `right-path2, SameConstraint(exp(verts[right-tip]), exp(point(right-path2))))
        MixCost(name, `fall, 0.1f, fall(m, all-joints, ground))
        MixCost(name, `above, 10.0f, above(m, all-joints, ground))
        MixCost(name, `wild-gyrate, wild-gyrations(gyration-time(1.0f), links))
        MixCost(name, `rnd-gyrate, rnd-gyrations(gyration-time(2.0f), links))
        MixCost(name, `inc-gyrate, inc-gyrations(gyration-time(3.0f), links))
        ]
        all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathFall
    (name:Symbol, radius:Float, param:Float, time:SymVar, spec:KinematicsExpSpec,
     bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>) -> BindBody :
  val all-joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val joints = to-tuple $ cat-all $ [[bottom-joints[1], bottom-joints[2], bottom-joints[3]] [left-joints[0]] [right-joints[0]]]
  TimeExpKinematics(name, time, spec, [ ], fn (m, verts) :
    val joint-verts = to-hashtable<Symbol,Vertex> $ for j in all-joints seq : j => verts[j]
    cat-all $ [[
      MixCost(name, `centering, 0.25f, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `fall, 0.1f, fall(m, joints, -8.0f))
      MixCost(name, `above, 10.0f, above(m, all-joints, -8.0f)) ]
      all-repels(name, joint-verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathGyrate
    (name:Symbol, radius:Float, param:Float, time:SymVar, spec:KinematicsExpSpec,
     bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>) -> BindBody :
  val all-joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val joints = to-tuple $ cat-all $ [[bottom-joints[1], bottom-joints[2], bottom-joints[3]] [left-joints[0]] [right-joints[0]]]
  TimeExpKinematics(name, time, spec, [ time ], fn (m, verts) :
    val joint-verts = to-hashtable<Symbol,Vertex> $ for j in all-joints seq : j => verts[j]
    val d = 2.0f
    val t = exp(time) * Const(2.0f * PI-F / d)
    ; val phases = for i in 0 to length(link-table(m)) seq: Const(0.5f * to-float(i))
    ; val phases = for i in 0 to length(link-table(m)) seq: Const(rnd(Box1f(1.0f)))
    ; ; sequential phases
    ; val ts = for i in 0 to length(link-table(m)) seq: t + Const(rnd(Box1f(1.0f)))
    ; ; random phases
    ; val ts = for i in 0 to length(link-table(m)) seq: t + Const(rnd(Box1f(1.0f)))
    ; ; random periods and phases
    val ts = for i in 0 to length(link-table(m)) seq: t * Const(rnd(Box1f(0.25f, 2.0f))) + Const(rnd(Box1f(1.0f)))
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `above, 10.0f, above(m, all-joints, -8.0f)) ]
      all-repels(name, joint-verts, vertex-collision-excludes(m))
      all-gyrations(name, ts, values(link-table(m)))
      ])

defn TimeExpKinematicsTestJoint
    (name:Symbol, idx:Int, time:SymVar, spec:KinematicsExpSpec) -> BindBody :
  TimeExpKinematics(name, time, spec, [ time ], fn (m, verts) :
    [ MixCost(name, `test, test-joint(idx, values(link-table(m)))) ])

defn TimeExpKinematicsPathCuffed
    (name:Symbol, radius:Float, param:Float, time:SymVar, spec:KinematicsExpSpec,
     origin-joint:Symbol, bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val target = SymVar(add-suffix(name, `target), 0.0f, false, false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val knee = bottom-joints[2]
  val mid = origin-joint
  TimeExpKinematics(name, time, spec, [ path, target ], fn (m, verts) :
    cat-all $ [[
      ; bondage with arms behind
      MixCost(name, `centering, centering(m, CenterConstraint, Const(V3f(0.0f, -4.0f, 0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `touch, DistanceConstraint(exp(verts[left-tip]), exp(verts[right-tip]), exp(target)))
      MixCost(name, `path, SameConstraint(exp(verts[mid]), exp(point(path))))
      MixCost(name, `above, 10.0f, above(m, joints, -8.0f)) ]
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathTied
    (name:Symbol, radius:Float, param:Float, time:SymVar, spec:KinematicsExpSpec,
     origin-joint:Symbol, bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val target = SymVar(add-suffix(name, `target), 0.0f, false, false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val knee = bottom-joints[1]
  val mid = origin-joint
  TimeExpKinematics(name, time, spec, [ path, target ], fn (m, verts) :
    cat-all $ [[
      ;bondage
      MixCost(name, `centering, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `touch, DistanceConstraint(verts[left-tip], verts[knee], Const(2.0f)))
      MixCost(name, `touch, DistanceConstraint(verts[right-tip], verts[knee], Const(2.0f)))
      MixCost(name, `path, SameConstraint(exp(verts[mid]), exp(point(path)))) ]
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathGrounded
    (name:Symbol, radius:Float, param:Float, time:SymVar, spec:KinematicsExpSpec,
     origin-joint:Symbol, bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val target = SymVar(add-suffix(name, `target), 0.0f, false, false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val knee = bottom-joints[2]
  val mid = origin-joint
  TimeExpKinematics(name, time, spec, [ path, target ], fn (m, verts) :
    cat-all $ [[
      ; bondage with both hands on ground
      MixCost(name, `path, SameConstraint(exp(verts[mid]), exp(point(path))))
      MixCost(name, `trace/y, SameConstraint(y(exp(verts[left-tip])), Const(-8.0f)))
      MixCost(name, `trace/y, SameConstraint(y(exp(verts[right-tip])), Const(-8.0f)))
      MixCost(name, `centering, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `above, 10.0f, above(m, joints, -8.0f))
      ]
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn merge (a:HashTable<Symbol,Vertex>, b:HashTable<Symbol,Vertex>) -> HashTable<Symbol,Vertex> :
  val res = HashTable<Symbol,Vertex>()
  for kv in a do : res[key(kv)] = value(kv)
  for kv in b do : res[key(kv)] = value(kv)
  res

defn TimeExpKinematicsPathCenter
    (name:Symbol, radius:Float, param:Float, time:SymVar, spec:KinematicsExpSpec,
     origin-joint:Symbol, bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val target = SymVar(add-suffix(name, `target), 0.0f, false, false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val knee = bottom-joints[2]
  val mid = origin-joint
  TimeExpKinematics(name, time, spec, [ path, target ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      ; MixCost(name, `torque, 2.0f, sum $ seq({ exp(torque(_)) }, values(link-table(m))))
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `path, SameConstraint(exp(verts[left-tip]), exp(point(path))))
      ]
      all-repels(name, merge(verts, mid-vertex-table(m)), vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathCenterStraighten
    (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
     bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     left-path:Path, left-tip:Symbol, right-path:Path, right-tip:Symbol) -> BindBody :
  val center-vertex = Vertex(add-suffix(name, `center), true, xyz(0.0f), false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  TimeExpKinematics(name, time, spec, [ left-path, right-path, center-vertex ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, exp(center-vertex))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `straighten, straighten(m))
      ; MixCost(name, `fall, fall(m, joints, -8.0f))
      ; MixCost(name, `fall, fall(m, [right-tip], -8.0f))
      MixCost(name, `on-line-right, OnLineConstraint(exp(verts[right-tip]), Const(V3f(-1.0f, 0.0f, 4.0f)), Const(V3f(1.0f, 0.0f, 4.0f)), Const(0.0f)))
      MixCost(name, `fall-right, fall(m, [right-tip], -8.0f))
      MixCost(name, `fall-left, fall(m, [left-tip], -8.0f))
      MixCost(name, `fall, centering(m, CenterConstraint, Const(V3f(0.0f, -10.0f, 0.0f)))),
      MixCost(name, `above, 10.0f, above(m, joints, -10.0f))
      ; MixCost(name, `fall, fall(m, [left-tip, right-tip], V3f(0.0f, -8.0f, 0.0f)))
      ; MixCost(name, `fall, SameConstraint(y(exp(verts[left-tip])), Const(-8.0f)) + SameConstraint(y(exp(verts[right-tip])), Const(-8.0f)))
      MixCost(name, `left-path, SameConstraint(exp(verts[left-tip]), exp(point(left-path))))
      MixCost(name, `right-path, SameConstraint(exp(verts[right-tip]), exp(point(right-path)))) ]
      ; for j in right-joints seq :
      ;   MixCost(name, symbol-join([`touch "/" j]), SameConstraint(exp(verts[left-tip]), exp(verts[j])))
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathCenterBase (name:Symbol, radius:Float, target:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val c = Const(xyz(0.0f))
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      ; MixCost(name, `base, SameConstraint(exp(y(verts[right-tip])), Const(target)))
      ; MixCost(name, `sphere, DistanceConstraint(exp(verts[right-tip]), c, Const(target)))
      MixCost(name, `path, SameConstraint(exp(verts[left-tip]), exp(point(path)))) ]
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathBind (name:Symbol, target:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val c = Const(xyz(0.0f))
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      ; MixCost(name, `base, SameConstraint(exp(y(verts[right-tip])), Const(target)))
      MixCost(name, `sphere, DistanceConstraint(exp(verts[right-tip]), exp(verts[left-tip]), Const(target)))
      MixCost(name, `path, SameConstraint(exp(verts[left-tip]), exp(point(path)))) ]
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathTrace (name:Symbol, target:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val c = Const(xyz(0.0f))
  println("TARGET %_" % [target])
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `trace/x, SameConstraint(exp(verts[right-tip]), Vec3Exp(x(exp(verts[left-tip])), Const(target), z(exp(verts[left-tip])))))
      MixCost(name, `centering, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      ; MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      ; MixCost(name, `sphere, DistanceConstraint(exp(verts[right-tip]), c, Const(target)))
      MixCost(name, `path, SameConstraint(exp(verts[left-tip]), exp(point(path)))) ]
      all-repels(name, verts, vertex-collision-excludes(m))
      ])

defn TimeExpKinematicsPathSphere (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val c = Const(xyz(0.0f))
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) : [
    (for v in verts do : println(key(v)), MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))))
    MixCost(name, `limit, limit-angles(m)),
    MixCost(name, `left-sphere, DistanceConstraint(exp(verts[left-tip]), c, Const(radius)))
    MixCost(name, `right-sphere, DistanceConstraint(exp(verts[right-tip]), c, Const(radius)))
    MixCost(name, `reflect, SameConstraint(reflect-y-mat-exp() * reflect-x-mat-exp() * exp(verts[right-tip]), exp(verts[left-tip])))
    MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

; defn TimeExpKinematicsPaths (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
;                              paths:Tuple<KeyValue<Float, Vertex>>, tip:Symbol) -> BindBody :
;   TimeExpKinematics(name, time, spec, to-tuple $ cat([ time ], seq(value, paths)),
;     fn (m, verts) : to-tuple $ cat-all $ [ [ MixCost(name, `centering, centering(m), Const(xyz(0.0f))) ],
;       for ([s, e] in successive-pairs(cat([0.0f], cumsum(seq(key, paths)))), path in seq(value, paths), i in 0 to false) seq :
;         println("S %_ E %_ V %_" % [s, e, id(path)])
;         MixCost(name, symbol-join([`path, i]), pulse(exp(time), Const(s), Const(e)), SameConstraint(exp(verts[tip]), exp(path))) ])
; 
; defn TimeExpKinematicsCurl (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec) -> BindBody :
;   TimeExpKinematics(name, time, spec, [ time ],
;     fn (m, verts) : to-tuple $ cat-all $ [ [
;       MixCost(name, `centering,  centering(m), Const(xyz(0.0f))),
;       MixCost(name, `limit,      limit-angles(m)) ]
;       for i in 0 to 4 seq-cat :
;         val o = to-float(i) * 20.0f
;         [ MixCost(name, symbol-join([`curl i]),       pulse(exp(time), Const(o +  0.0f), Const(o + 10.0f)), curl-angles(m)),
;           MixCost(name, symbol-join([`straighten i]), pulse(exp(time), Const(o + 10.0f), Const(o + 20.0f)), straighten(m)) ],
;       ])

defn TimeExpKinematicsPathStraighten (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) : [
    MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
    MixCost(name, `straighten, 0.1f, straighten(m)),
    MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

defn TimeExpKinematicsCircle (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val r = SymVar(`radius, 1.0f * radius, false)
  val circ  = Circle(`circle, Vertex(`center, V3f(0.0f, 0.0f, -4.0f)), r, true, false)
  TimeExpKinematics(name, time, spec, [ path, circ, r ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m)),
      MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(point(path))))
      MixCost(name, `circle, ProjectOntoCircle(verts[left-tip], circ)) ])

defn TimeExpKinematicsPathWrist (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol, wrist:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m)), 
      MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path))))
      MixCost(name, `horizontal, HorizontalConstraint(exp(edge(link-table(m)[wrist])))) ])

defn TimeExpKinematicsPathStraight (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol, side:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) :
      val links = to-tuple $ for entry in link-table(m) filter :
        prefix?(to-string(key(entry)), to-string(side)) and axis(value(entry)) == 2
      cat-all $ [ [ MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
                    MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ]
        for (link in links, i in 0 to false) seq :
          MixCost(name, symbol-join([`link, i]), 4.0f, SameConstraint(exp(angle(value(link))), Const(0.0f))) ] )

defn TimeExpKinematicsReflect (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m))
     MixCost(name, `reflect, SameConstraint(reflect-y-mat-exp() * reflect-x-mat-exp() * exp(verts[right-tip]), exp(verts[left-tip])))
     MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(point(path)))) ])

defn TimeExpKinematicsMirror (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m))
      MixCost(name, `mirror, SameConstraint(
       mov-mat-exp(Const(y3f(20.0f))) * mag-mat-exp(0.5f) * exp(verts[right-tip]),
       exp(verts[left-tip])))
      MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(point(path)))) ])

defn TimeExpKinematicsBounce (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val path1 = (reflect-xy-mat-exp() * bounce(24.0f, 2.0f, time)) + Const(V3f(0.0f, 8.0f, 0.0f))
  ; val path1 = bounce(12.0f, 2.0f, time) + Const(V3f(-8.0f, 4.0f, 0.0f))
  val path2 = bounce(4.0f, 0.5f, time)  + Const(V3f(0.0f,  2.0f, 0.0f))
  ; val path2 = bounce(3.0f, 1.0f, time) + exp(vertex-table(m)[`origin]) - Const(V3f(0.0f, 1.5f, 0.0f))
  TimeExpKinematics(name, time, spec, [ time ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m))
      MixCost(name, `limit,      limit-angles(m))
      MixCost(name, `path, SameConstraint(exp(verts[right-tip]), path1))
      MixCost(name, `bounce, SameConstraint(y(exp(verts[`origin])), y(path2))) ])

defn TimeLeg (name:Symbol, radius:Float, time:SymVar) -> BindBody :
  val path = PolyLinePath(`path, time, mag(xyz(radius)) $ square-path, 4.0f)
  val body = KinematicsBody(`main, robot-leg-spec)
  BindBody(`tkb, body,
           fn (m) : []
           fn (m) : cat-all $ [
             [ a(links(m)[0]) => Const(V3f(0.0f, 0.0f, 0.0f))
               b(last(links(m))) => exp(point(path)) ]
             ]
           to-tuple $ cat-all $ seq(vars, [path]))
      
val robot-arm-spec =
  KinematicsSpec([LinkSpec(`lower, 10.0f), LinkSpec(`upper, 10.0f)],
                 [JointSpec(`elbow, HingeJoint, `lower, `upper)])

val robot-leg-spec =
  KinematicsSpec([LinkSpec(`ankle, 5.0f), LinkSpec(`calf, 10.0f), LinkSpec(`thigh, 10.0f)],
                 [JointSpec(`ankle, RotaryJoint, `ankle, `calf), JointSpec(`knee, HingeJoint, `calf, `thigh)])

val robot-arm-spec0 =
  KinematicsSpec([LinkSpec(`lower, 10.0f)], [])

val robot-arm-exp-spec =
  KinematicsExpSpec(
    `shoulder,
    [LinkExpSpec(`fore-arm, `hand, `elbow, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `fore-arm, `upper-arm),
     LinkExpSpec(`upper-arm, `elbow, `shoulder, 10.0f)])

val robot-arm-exp-spec2 =
  KinematicsExpSpec(
    `torso,
    [LinkExpSpec(`fore-arm, `elbow,     `hand, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm),
     LinkExpSpec(`upper-arm, `shoulder, `elbow, 10.0f)
     JointExpSpec(`origin, 2, default-limits, `base, `upper-arm),
     LinkExpSpec(`base,      `torso,    `shoulder, 0.0f)
     ])

val robot-arm-exp-spec3 =
  KinematicsExpSpec(
    `origin,
    [LinkExpSpec(`hand, `wrist,     `finger, 5.0f),
     JointExpSpec(`wrist, 2, default-limits, `fore-arm, `hand),
     LinkExpSpec(`fore-arm, `elbow,     `wrist, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm),
     LinkExpSpec(`upper-arm, `shoulder, `elbow, 10.0f)
     JointExpSpec(`origin, 2, default-limits, `pivot, `upper-arm),
     LinkExpSpec(`pivot, `torso, `shoulder, 1.0f)
     JointExpSpec(`torso, 1, default-limits, `base, `pivot),
     LinkExpSpec(`base,      `origin,    `torso, 0.0f)
     ])

val open-manipulator-x-spec =
  KinematicsExpSpec(
    `origin,
    [LinkExpSpec(`hand, `wrist,     `finger, 14.66f),
     JointExpSpec(`wrist, 2, default-limits, `fore-arm, `hand),
     LinkExpSpec(`fore-arm, `elbow,     `wrist, 12.4f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm),
     LinkExpSpec(`upper-arm, `shoulder, `elbow, 12.8f)
     JointExpSpec(`origin, 2, default-limits, `pivot, `upper-arm),
     LinkExpSpec(`pivot, `torso, `shoulder, 4.6f)
     JointExpSpec(`torso, 1, default-limits, `base, `pivot),
     LinkExpSpec(`base,      `origin,    `torso, 3.0f)
     ])

val robot-leg-arm-exp-spec =
  KinematicsExpSpec(
    `foot,
    [LinkExpSpec(`ankle, `foot, `knee, 10.0f)
     JointExpSpec(`knee, 2, default-limits, `ankle, `thigh)
     LinkExpSpec(`thigh, `knee, `torso, 10.0f),
     JointExpSpec(`torso, 2, default-limits, `thigh, `upper-arm),
     LinkExpSpec(`upper-arm, `torso, `elbow, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm)
     LinkExpSpec(`fore-arm, `elbow, `hand, 10.0f)])

defn robot-arm (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base:Symbol) : symbol-join $ [side "-" base]
  [ LinkExpSpec(nameit(`upper-arm), `torso, nameit(`elbow), 10.0f),
    JointExpSpec(nameit(`elbow), 2, default-limits, nameit(`upper-arm), nameit(`fore-arm))
    LinkExpSpec(nameit(`fore-arm), nameit(`elbow), nameit(`hand), 10.0f) ]

defn robot-leg () -> Seqable<LinkExpSpec|JointExpSpec> :
  [ LinkExpSpec(`ankle, `foot, `knee, 10.0f),
    JointExpSpec(`knee, 2, default-limits, `ankle, `thigh)
    LinkExpSpec(`thigh, `knee, `torso, 10.0f) ]

val robot-simple-body-exp-spec =
  KinematicsExpSpec(`foot,
    cat-all $ [
      robot-arm(`left)
      robot-arm(`right)
      robot-leg()
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `thigh, `left-upper-arm)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `thigh, `right-upper-arm) ]
      ] )

; defn robot-arm2 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
;   defn nameit (base:Symbol) : symbol-join $ [side "-" base]
;   [LinkExpSpec(nameit(`base),      `origin,    nameit(`torso), 2.0f)
;    JointExpSpec(nameit(`torso), 1, default-limits, nameit(`base), nameit(`pivot)),
;    LinkExpSpec(nameit(`pivot), nameit(`torso), nameit(`shoulder), 4.0f)
;    JointExpSpec(nameit(`origin), 2, default-limits, nameit(`pivot), nameit(`upper-arm)),
;    LinkExpSpec(nameit(`upper-arm), nameit(`shoulder), nameit(`elbow), 8.0f)
;    JointExpSpec(nameit(`elbow), 2, default-limits, nameit(`upper-arm), nameit(`fore-arm)),
;    LinkExpSpec(nameit(`fore-arm), nameit(`elbow),     nameit(`wrist), 4.0f),
;    JointExpSpec(nameit(`wrist), 1, default-limits, nameit(`fore-arm), nameit(`hand)),
;    LinkExpSpec(nameit(`hand), nameit(`wrist),     nameit(`finger), 2.0f),
;    ]

defn robot-arm2 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base) : symbol-join $ [side "-" base]
  [LinkExpSpec(nameit("L0"), `origin,      nameit("J0"), 2.0f)
   JointExpSpec(nameit("J0"), 1, default-limits, nameit("L0"), nameit("L1")),
   LinkExpSpec(nameit("L1"), nameit("J0"), nameit("J1"), 4.0f)
   JointExpSpec(nameit("J1"), 2, default-limits, nameit("L1"), nameit("L2")),
   LinkExpSpec(nameit("L2"), nameit("J1"), nameit("J2"), 8.0f)
   JointExpSpec(nameit("J2"), 2, default-limits, nameit("L2"), nameit("L3")),
   LinkExpSpec(nameit("L3"), nameit("J2"), nameit("J3"), 4.0f),
   JointExpSpec(nameit("J3"), 1, default-limits, nameit("L3"), nameit("L4")),
   LinkExpSpec(nameit("L4"), nameit("J3"), nameit(`tip), 2.0f),
   ]

val robot-simple-body-exp-spec2 =
  KinematicsExpSpec(`bottom-tip,
    cat-all $ [
      robot-arm2(`left)
      robot-arm2(`right)
      robot-arm2(`bottom)
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-L0, `left-L0)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-L0, `right-L0) ]
      ] )

defn robot-arm3 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base:Symbol) : symbol-join $ [side "-" base]
  [LinkExpSpec(nameit(`base),      `origin,    nameit(`torso), 4.0f)
   JointExpSpec(nameit(`torso), 1, default-limits, nameit(`base), nameit(`upper-arm)),
   LinkExpSpec(nameit(`upper-arm), nameit(`torso), nameit(`elbow), 8.0f)
   JointExpSpec(nameit(`elbow), 2, default-limits, nameit(`upper-arm), nameit(`fore-arm)),
   LinkExpSpec(nameit(`fore-arm), nameit(`elbow),     nameit(`wrist), 8.0f),
   JointExpSpec(nameit(`wrist), 1, default-limits, nameit(`fore-arm), nameit(`hand)),
   LinkExpSpec(nameit(`hand), nameit(`wrist),     nameit(`finger), 4.0f),
   ]

val robot-simple-body-exp-spec3 =
  KinematicsExpSpec(`bottom-finger,
    cat-all $ [
      robot-arm3(`left)
      robot-arm3(`right)
      robot-arm3(`bottom)
      [ JointExpSpec(`left-hip, 0.085f, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-base, `left-base)
        JointExpSpec(`right-hip, 0.085f, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-base, `right-base) ]
      ] )

defn robot-arm4 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base) : symbol-join $ [side "-" base]
  [LinkExpSpec(nameit("L0"), `origin,      nameit("J0"), 2.0f)
   JointExpSpec(nameit("J0"), 1, default-limits, nameit("L0"), nameit("L1")),
   LinkExpSpec(nameit("L1"), nameit("J0"), nameit("J1"), 2.0f)
   JointExpSpec(nameit("J1"), 2, default-limits, nameit("L1"), nameit("L2")),
   LinkExpSpec(nameit("L2"), nameit("J1"), nameit("J2"), 4.0f)
   JointExpSpec(nameit("J2"), 2, default-limits, nameit("L2"), nameit("L3")),
   LinkExpSpec(nameit("L3"), nameit("J2"), nameit("J3"), 4.0f),
   JointExpSpec(nameit("J3"), 2, default-limits, nameit("L3"), nameit("L4")),
   LinkExpSpec(nameit("L4"), nameit("J3"), nameit("J4"), 2.0f),
   JointExpSpec(nameit("J4"), 1, default-limits, nameit("L4"), nameit("L5")),
   LinkExpSpec(nameit("L5"), nameit("J4"), nameit(`tip), 2.0f),
   ]

val robot-simple-body-exp-spec4 =
  KinematicsExpSpec(`bottom-tip,
    cat-all $ [
      robot-arm4(`left)
      robot-arm4(`right)
      robot-arm4(`bottom)
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-L0, `left-L0)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-L0, `right-L0) ]
      ] )

val angle-limits = [default-limits, default-z-limits, default-x-limits]

defn robot-arm5 (nameit:(Symbol, Int) -> Symbol, links:Tuple<Float>, joints:Tuple<Int>) -> Seqable<LinkExpSpec|JointExpSpec> :
  val res = to-tuple $ cat-all $ [
    for (l in links, idx in 0 to false) seq :
      LinkExpSpec(nameit(`l, idx), 0.015f, nameit(`j, idx), nameit(`j, idx + 1), l)
    for (j in joints, idx in 1 to false) seq :
      JointExpSpec(nameit(`j, idx), 0.085f, j, angle-limits[j], nameit(`l, idx - 1), nameit(`l, idx))
    ]
  ; println(res)
  res

defn nameit (side:Symbol, kind:Symbol, idx:Int) :
  if kind == `j and idx == 0 :
    `origin
  else :
    symbol-join $ [side "-" kind idx]

; val robot-simple-body-exp-spec5 =
;   KinematicsExpSpec(`bottom-j6,
;     cat-all $ [
;       robot-arm5(nameit{`left, _, _},   [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
;       robot-arm5(nameit{`right, _, _},  [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
;       robot-arm5(nameit{`bottom, _, _}, [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
;       [ JointExpSpec(`left-hip,  2, Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-l0, `left-l0)
;         JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-l0, `right-l0) ]
;       ] )

val hip-ang = 1.0f * PI-F
; val equilateral-triangle-inscribed-radius = (sqrt(3.0f) / 2.0f) * 2.85f
; val first-link-len = 3.4f + equilateral-triangle-inscribed-radius
val first-link-len = 4.7f
val robot-simple-body-exp-spec5 =
  KinematicsExpSpec(`bottom-j6,
  ; KinematicsExpSpec(`bottom-j5,
    cat-all $ [
      robot-arm5(nameit{`left, _, _},   [first-link-len, 4.3f, 15.0f, 15.0f], [1, 2, 2])
      robot-arm5(nameit{`right, _, _},  [first-link-len, 4.3f, 15.0f, 15.0f], [1, 2, 2])
      robot-arm5(nameit{`bottom, _, _}, [first-link-len, 5.245f, 15.0f, 15.0f, 5.26f, 4.73f], [1, 2, 2, 2, 1])
      ; robot-arm5(nameit{`bottom, _, _}, [2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 1])
      [ JointExpSpec(`left-hip,  0.020f, 2, Box1f((- hip-ang)), `bottom-l0, `left-l0)
        JointExpSpec(`right-hip, 0.020f, 2, Box1f(   hip-ang ), `bottom-l0, `right-l0) ]
      ]
    10.0f)

; val robot-simple-body-exp-spec5 = 
;   KinematicsExpSpec(`bottom-j2,
;     cat-all $ [
;       robot-arm5(nameit{`left, _, _}, [2.0f, 2.0f], [2])
;       robot-arm5(nameit{`right, _, _}, [2.0f, 2.0f], [2])
;       robot-arm5(nameit{`bottom, _, _}, [2.0f, 2.0f], [2])
;       [ JointExpSpec(`left-hip,  2, Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-l0, `left-l0)
;         JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-l0, `right-l0) ]
;       ] )

; val robot-body-exp-spec =
;   KinematicsExpSpec(
;     `foot,
;     [LinkExpSpec(`ankle, `foot, `knee, 10.0f), LinkExpSpec(`thigh, `knee, `dick, 10.0f),
;      LinkExpSpec(`center-torso, `dick, `torso, 5.0f),
;      LinkExpSpec(`left-torso, `torso, `left-shoulder, 5.0f),
;      LinkExpSpec(`right-torso, `torso, `right-shoulder, 5.0f)
; 
;      LinkExpSpec(`left-upper-arm, `left-shoulder, `left-elbow, 10.0f), LinkExpSpec(`left-fore-arm, `left-elbow, `left-hand, 10.0f), ,
;      LinkExpSpec(`right-upper-arm, `right-shoulder, `right-elbow, 10.0f), LinkExpSpec(`right-fore-arm, `right-elbow, `right-hand, 10.0f),
;
;     [JointExpSpec(`left-elbow, 2, false, `left-upper-arm, `left-fore-arm)
;      JointExpSpec(`right-elbow, 2, false, `right-upper-arm, `right-fore-arm)
;      JointExpSpec(`knee, 2, false, `ankle, `thigh)
;      ])

defn set-costs (b:Body, pred:Cost -> True|False) :
  clear(costs(b))
  add-all(costs(b), filter(pred, all-costs(b)))
  for c in costs(b) do :
    println(name(c))
defn set-costs (b:Body, costs:Seqable<Cost>) :
  set-costs(b, fn (c) : any?({ name(_) == name(c) }, costs))

defn add-costs (b:Body, new-costs:Tuple<Cost>) :
  rem-costs(b, new-costs)
  add-all(costs(b), filter(fn (c) : any?({ name(_) == name(c) }, new-costs), all-costs(b)))
  for c in costs(b) do :
    println(name(c))

defn rem-costs (b:Body, new-costs:Seqable<Cost>) :
  for c in new-costs do :
    remove-when({name(_) == name(c)}, costs(b))
  for c in costs(b) do :
    println(name(c))

public deftype DanceScheduler <: Scheduler
defn DanceScheduler (b:Body, make-sched:Body -> Seq<Phrase>, x-0:Float, x-1:Float, exec : () -> ?) -> DanceScheduler :
  val state = SchedulerState()
  val sched = make-sched(b)
  new DanceScheduler :
    defmethod state (this) : state
    defmethod body (this) : b
    defmethod schedule (this) : sched
    defmethod exec (this) : exec()

defn simple-sched (b:Body) -> Seq<Phrase> :
  repeatedly({ Phrase(1.0f) })

defn two-paths-sched (b:Body, x-0:Float, x-1:Float) -> Seq<Phrase> :
  val ptab = to-hashtable<Symbol,Path> $ for p in filter-by<Path>(entities(b)) seq : name(p) => p
  val left-path  = ptab[`left-path]
  val right-path = ptab[`right-path]
  val base-cost-names = [ `main/base `main/basing `main/centering `main/limit `main/repel ]
  val cost = to-hashtable<Symbol, Cost> $ for c in all-costs(b) seq : name(c) => c
  generate<Phrase> :
    var last-pt = V3f(0.0f, 0.0f, 0.0f)
    set-next(point(right-path), PointInterpolator(last-pt))
    while true :
      ; set-costs(b, cat(base-costs, [ `main/left-path `main/right-path ]))
      ; set-next(point(right-path), PointInterpolator(last-pt))
      ; val pt = rnd(dims-to-box $ xyz(x-0))
      ; println("LPOINT %_ %_" % [last-pt, pt])
      ; set-next(point(left-path), PointInterpolator(pt))
      ; yield(Phrase(2.0f))
      ; set-costs(b, cat(base-costs, [ `main/left-path `main/; touch ]))
      ; set-costs(b, cat(base-costs, [ `main/; touch ]))
      ; println("TOUCH")
      ; yield(Phrase(2.0f))
      ; last-pt = pt

      set-costs(b, seq({ cost[_] }, base-cost-names))
      add-costs(b, [ cost[`main/left-path] cost[`main/right-path] ])
      val pt = rnd(dims-to-box $ xyz(x-0)) + y3f(x-1)
      println("LPOINT %_" % [pt])
      set-next(point(left-path), PointInterpolator(pt))
      yield(Phrase(1.0f))
      set-next(point(right-path), PointInterpolator(pt))
      ; set-costs([ `main/touch ])
      println("RPOINT")
      yield(Phrase(1.0f))

      ; set-costs(b, cat(base-costs, [ `main/right-path ]))
      ; println("SQUARE")
      ; set-next(point(left-path), PolyLinePathInterpolator(mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f))
      ; yield(Phrase(4.0f))
      ; println("CUBE")
      ; set-next(point(left-path), PolyLinePathInterpolator(mov-y(x-1) $ mag(xyz(x-0)) $ cube-path, 4.0f))
      ; yield(Phrase(4.0f))

defn sigmoid (x:Float, t:Float) -> Float : 1.0f / (1.0f + exp(-1.0f * t * x))

defn fade-in (b:Body, yield:Phrase -> ?, duration:Float, costs:Tuple<Cost>, work:Float -> ?) :
  add-costs(b, costs)
  yield(Phrase(duration, fn (t) :
    work(t)
    for c in costs do: set-gain(c, sigmoid(20.0f * (t / duration - 0.5f), 0.5f))))

defn fade-in (b:Body, yield:Phrase -> ?, duration:Float, costs:Tuple<Cost>) :
  fade-in(b, yield, duration, costs, { false })

defn fade-out (b:Body, yield:Phrase -> ?, duration:Float, costs:Tuple<Cost>, work:Float -> ?) :
  yield(Phrase(duration, fn (t) :
    work(t)
    for c in costs do : set-gain(c, sigmoid(20.0f * (0.5f - t / duration), 0.5f))))
  rem-costs(b, costs)

defn fade-out (b:Body, yield:Phrase -> ?, duration:Float, costs:Tuple<Cost>) :
  fade-out(b, yield, duration, costs, { false })

defn cross-fade (b:Body, yield:Phrase -> ?, duration:Float,
                 out-costs:Tuple<Cost>, out-work:Float -> ?, in-costs:Tuple<Cost>, in-work:Float -> ?) :
  add-costs(b, in-costs)
  yield(Phrase(duration, fn (t) :
    out-work(t)
    for c in out-costs do :
      set-gain(c, sigmoid(20.0f * (0.5f - t / duration), 0.5f))
    in-work(t)
    for c in in-costs do :
      set-gain(c, sigmoid(20.0f * (t / duration - 0.5f), 0.5f))))
  rem-costs(b, out-costs)

defn cross-fade (b:Body, yield:Phrase -> ?, duration:Float, out-costs:Tuple<Cost>, in-costs:Tuple<Cost>) :
  cross-fade(b, yield, duration, out-costs, { false }, in-costs, { false })


defn rnd-sched (b:Body, x-0:Float, x-1:Float) -> Seq<Phrase> :
  val vtab = to-hashtable<Symbol,Vertex> $ for v in vertices(b) seq : name(v) => v
  val base-costs = [ `main/base `main/basing `main/centering `main/limit `main/repel ]
  val symvar-tbl = to-hashtable<Symbol,SymVar> $ for v in symvars(b) seq : name(v) => v
  val target = symvar-tbl[`main/target]
  val cost = to-hashtable<Symbol, Cost> $ for c in all-costs(b) seq : name(c) => c
  generate<Phrase> :
    set-costs(b, seq({ cost[_] },  [ `main/base `main/basing `main/above ]))
    yield(Phrase(2.0f))
    set-costs(b, seq({ cost[_] },  [ `main/base `main/basing `main/above `main/centering `main/sphere `main/path ]))
    ; yield(fade-in(8.0f, fn (nx) : set-x(target, 16.0f * nx))))
    set-costs(b, seq({ cost[_] },  [ `main/base `main/basing `main/above ]))
    yield(Phrase(4.0f))
    set-costs(b, seq({ cost[_] },  [ `main/base `main/basing `main/above `main/centering `main/sphere `main/path ]))
    yield(Phrase(100.0f))

defn dof-sched (b:Body, time:SymVar, orbit-particle1:OrbitParticle, orbit-particle2:OrbitParticle, path1:PolyLinePath, path2:PolyLinePath) -> Seq<Phrase> :
  val ptab = to-hashtable<Symbol,Path> $ for p in filter-by<Path>(entities(b)) seq : id(p) => p
  val stab = to-hashtable<Symbol,SymVar> $ for v in filter-by<SymVar>(entities(b)) seq : id(v) => v
  val left-path1 = ptab[`left-path1]
  val left-path2 = ptab[`left-path2]
  val right-path1 = ptab[`right-path1]
  val right-path2 = ptab[`right-path2]
  val target = stab[`main/target]
  val cost = to-hashtable<Symbol, Cost> $ for c in all-costs(b) seq : name(c) => c
  generate<Phrase> :
    set-costs(b, [ cost[`main/base] cost[`main/basing] cost[`main/above] cost[`main/limit] ]) ; cost[`main/repel]

    println("--- FALL")
    fade-in(b, yield, 2.0f, [ cost[`main/fall ] ])

    println("--- GROUNDED")
    ; grounded  -- x -- radius(x-0) 6.0 center(x-1) y3f(0.0) duration(x-3) 1.0
    set-next(point(left-path2), interpolator-of(set-params(orbit-particle2, y3f(0.0f), 8.0f, 0.5f)))
    cross-fade(b, yield, 8.0f, [ cost[`main/fall] ]
      [ cost[`main/centering-xz] cost[`main/origin-path2] cost[`main/left-ground] cost[`main/right-ground]  ])
    yield(Phrase(2.0f))
    
    println("--- TRACE")
    ; trace     -- x -- radius 8.0 center y3f(3.0) duration 3.0 target -8.0
    set-x(target, -10.0f)
    set-next(point(left-path1), interpolator-of(set-params(orbit-particle1, y3f(4.0f), 10.0f, 2.0f)))
    cross-fade(b, yield, 8.0f, [ cost[`main/origin-path2], cost[`main/left-ground] cost[`main/right-ground] ]
                               [ cost[`main/left-path1], cost[`main/left-trace] ])
    yield(Phrase(4.0f))
    
    ; println("--- TWIST")
    ; ; twist     -- x -- mag(x-0) 8.0 moy-y(x-1) 0.0 duration-fac(x-2) 2.0  -- 
    ; val [twist-mag, twist-y, twist-duration] = [8.0f, 0.0f, 2.0f]
    ; set-next(point(left-path2), PolyLinePathInterpolator(time,
    ;   mov-y(twist-y) $ reflect-x $ reflect-yz $ mag(xyz(twist-mag)) $ round-you, duration(path1), phase(path1)))
    ; set-next(point(right-path2), PolyLinePathInterpolator(time,
    ;   mov-y(twist-y) $ reflect-yz $ mag(xyz(twist-mag)) $ round-you, duration(path2), phase(path2)))
    ; set-x(duration(path1), twist-duration)
    ; set-x(duration(path2), twist-duration)
    ; cross-fade(b, yield, 4.0f, [ cost[`main/left-path1] cost[`main/left-trace] ]
    ;                            [ cost[`main/left-path2] cost[`main/right-path2] ])
    ; yield(Phrase(4.0f))
    
    println("--- HULU")
    ; hulu      -- x -- mag(x-0) 8.0 mov-y(x-1) 3.0 duration-fac(x-2) 0.6
    val [hulu-mag, hulu-y, hulu-duration] = [8.0f, 3.0f, 0.6f]
    set-next(point(left-path2), PolyLinePathInterpolator(time,
      mov-y(hulu-y) $ mov-x(-8.0f) $ reflect-xz $ mag(xyz(hulu-mag)) $ circle-line, duration(path1), phase(path1)))
    set-next(point(right-path2), PolyLinePathInterpolator(time,
      mov-y(hulu-y) $ mov-x(8.0f) $ reflect-xz $ mag(xyz(hulu-mag)) $ circle-line, duration(path2), phase(path2)))
    set-x(duration(path1), 4.0f * hulu-duration)
    set-x(duration(path2), 3.0f * hulu-duration)
    cross-fade(b, yield, 4.0f, [ cost[`main/left-path1] cost[`main/left-trace] ]
                               [ cost[`main/left-path2] cost[`main/right-path2] ])
    ; cross-fade(b, yield, 4.0f, [ cost[`main/left-path1] cost[`main/right-path2] cost[`main/centering-xz] ]
    ;                            [ cost[`main/left-path1] cost[`main/right-path1] cost[`main/centering-xyz] ])
    yield(Phrase(4.0f))
      
    println("--- GYRATE")
    ; gyrate    -- x -- radius(x-0) 8.0 param(x-2) 12.0 -- successive and rnd phases
    cross-fade(b, yield, 4.0f, [ cost[`main/left-path2] cost[`main/right-path2] cost[`main/centering-xz] ]
                               [ cost[`main/inc-gyrate] cost[`main/centering-xyz] ])
    yield(Phrase(2.0f))
    cross-fade(b, yield, 2.0f, [ cost[`main/inc-gyrate] ]  [ cost[`main/rnd-gyrate] ])
    yield(Phrase(2.0f))
    cross-fade(b, yield, 2.0f, [ cost[`main/rnd-gyrate] ]  [ cost[`main/wild-gyrate] ])
    yield(Phrase(2.0f))
     
    println("--- PAUSE")
    ; fall      -- x
    cross-fade(b, yield, 4.0f, [ cost[`main/wild-gyrate] ]  [ ] )
    yield(Phrase(4.0f))
    
    println("--- BIND")
    ; bind      -- x -- radius(x-0) 8.0 center(x-1) y3f(0.0) duration(x-2) 2.0 target(x-3) 2.0 and 16.0 -- close and far
    set-next(point(left-path1), interpolator-of(set-params(orbit-particle1, y3f(6.0f), 12.0f, 2.0f)))
    set-x(target, 2.0f)
    cross-fade(b, yield, 4.0f, [ cost[`main/fall ] ]  [ cost[`main/left-path1 ] cost[`main/bind] ])
    yield(Phrase(8.0f))
    println("--- BIND SEPARATION")
    fade-in(b, yield, 4.0f, [ ] { (val x = 2.0f + 10.0f * _ / 4.0f, set-x(target, x)) })
    yield(Phrase(8.0f))

    println("--- ORBIT")
    ; orbit     -- x -- radius(x-0) 8.0 center(x-1) y3f(6.0) x-2 12.0
    set-next(point(left-path2), interpolator-of(set-params(orbit-particle2, y3f(6.0f), 16.0f, 4.0f)))
    cross-fade(b, yield, 4.0f, [ cost[`main/left-path1] cost[`main/bind] ] [ cost[`main/left-path2] ])
    yield(Phrase(20.0f))

    println("--- FALL")
    cross-fade(b, yield, 4.0f, [ cost[`main/left-path2] ]  [ cost[`main/fall ] ])
    yield(Phrase(4.0f))

    while true :
      yield(Phrase(2.0f))

defn one-path-sched (b:Body, right-joints:Tuple<Symbol>, orbit-particle:OrbitParticle, x-0:Float, x-1:Float) -> Seq<Phrase> :
  val ptab = to-hashtable<Symbol,Path> $ for p in filter-by<Path>(entities(b)) seq : id(p) => p
  val left-path  = ptab[`left-path]
  val right-path = ptab[`right-path]
  val base-costs = [ `main/base `main/basing `main/centering `main/straighten `main/limit `main/repel ]
  val cost = to-hashtable<Symbol, Cost> $ for c in all-costs(b) seq : name(c) => c
  ; val touch-costs = to-tuple $ for j in right-joints seq : symbol-join([`main "/" `touch "/" j])
  generate<Phrase> :
    set-costs(b, [ cost[`main/base] cost[`main/basing] cost[`main/above] cost[`main/limit] ]) ; cost[`main/repel]
    yield(Phrase(2.0f))
    ; set-costs(b, [ `main/base `main/basing `main/above `main/straighten])
    ; yield(fade-in(3.0f, set-gain{straighten-cost, _}))
    ; set-costs(b, [ `main/base `main/basing `main/above `main/fall ])
    ; yield(fade-in(2.0f, set-gain{fall-cost, _}))
    ; set-costs(b, [ `main/base `main/basing `main/above `main/straighten ])
    ; yield(fade-in(2.0f, set-gain{straighten-cost, _}))
    ; set-costs(b, [ `main/base `main/basing `main/above `main/fall ])
    ; yield(fade-in(3.0f, set-gain{fall-cost, _}))

    ; for c in touch-costs do :
    ;   set-costs(b, [ `main/base `main/basing `main/above c ])
    ;   yield(Phrase(2.0f))
    ; set-costs(b, [ `main/base `main/basing, `main/fall ])
    ; yield(Phrase(4.0f))
    ; set-gain(fall-cost, 10.0f)
    ; set-next(point(left-path), PointInterpolator(V3f(-4.0f, -8.0f, 0.0f)))
    ; set-next(point(right-path), PointInterpolator(V3f(4.0f, -8.0f, 0.0f)))
    ; set-costs(b, [ `main/base `main/basing `main/above `main/left-path `main/right-path ])
    ; yield(fade-in(4.0f, fn (g) : (set-gain(left-path-cost, g), set-gain(right-path-cost, g))))
    ; set-costs(b, [ `main/base `main/basing, `main/straighten ])
    ; yield(Phrase(2.0f))
    
    println("--- ORBIT LEFT WITH POINT RIGHT")
    set-next(point(left-path), interpolator-of(set-params(orbit-particle, xyz(0.0f), x-0, 3.0f)))
    set-next(point(right-path), PointInterpolator(V3f(4.0f, 8.0f, 0.0f)))
    fade-in(b, yield, 4.0f, [ cost[`main/left-path] cost[`main/right-path] ])
    yield(Phrase(4.0f))

    println("--- ORBIT LEFT WITH LINE RIGHT")
    cross-fade(b, yield, 4.0f, [ cost[`main/right-path] ] [ cost[`main/on-line-right] ] )
    yield(Phrase(4.0f))

    println("--- ORBIT LEFT WITH PLANE RIGHT")
    cross-fade(b, yield, 4.0f, [ cost[`main/on-line-right] ] [ cost[`main/fall-right] ] )
    yield(Phrase(4.0f))

    println("--- STRAIGHTEN")
    cross-fade(b, yield, 2.0f, [ cost[`main/fall-right] ], [ cost[`main/straighten] ])

    println("--- ORBIT CENTERED")
    set-next(point(left-path), interpolator-of(set-params(orbit-particle, xyz(0.0f), x-0, 3.0f)))
    cross-fade(b, yield, 4.0f, [ cost[`main/straighten] ] [ cost[`main/centering] cost[`main/left-path] ])
    yield(Phrase(4.0f))

    println("--- STRAIGHTEN")
    cross-fade(b, yield, 2.0f, [ cost[`main/centering] cost[`main/left-path] ] [ cost[`main/straighten] ] )

    println("--- RELAX")
    fade-out(b, yield, 2.0f, [ cost[`main/straighten] ])

    while true :
      yield(Phrase(2.0f))

defn demo (top-name:String, n-0:Int, n-1:Int, n-2:Int, x-0:Float, x-1:Float, x-2:Float, x-3:Float) :
  val time = SymVar(`time, 0.0f, false, false)
  var sched : Body -> Seq<Phrase> = simple-sched
  val m =
    switch(top-name) :
      "robot-arm0" : KinematicsBody(`main, robot-arm-spec0)
      "robot-arm" : KinematicsBody(`main, robot-arm-spec)
      "robot-arm-exp" : KinematicsExpBody(`main, robot-arm-exp-spec)
      "robot-arm-exp2" : KinematicsExpBody(`main, robot-arm-exp-spec2)
      "robot-arm-exp3" : KinematicsExpBody(`main, robot-arm-exp-spec3)
      "open-manipulator-x" : KinematicsExpBody(`main, open-manipulator-x-spec)
      "simple-robot-exp" : KinematicsExpBody(`main, robot-simple-body-exp-spec)
      "simple-robot-exp2" : KinematicsExpBody(`main, robot-simple-body-exp-spec2)
      "robot-leg-arm" : KinematicsExpBody(`main, robot-leg-arm-exp-spec)
      "robot-leg" : KinematicsBody(`main, robot-leg-spec)
      "kinematics" : KinematicsExpBody2(`main)
      ; "time-kinematics" : TimeKinematics(`main, x-0, time)
      ; "time-exp-kinematics" : TimeExpKinematics(`main, x-0, time, robot-arm-exp-spec3, `finger)
      ; "time-exp-kinematics-real" : TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec2, `right-tip)
      ; "time-exp-kinematics-real3" : TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec3, `right-finger)
      ; "time-exp-kinematics-real4" : TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec4, `right-tip)
      "dof" :
        val left-path1  = OrbitParticle(`left-path1, time, y3f(x-1), x-0, x-3)
        val right-path1 = OrbitParticle(`right-path1, time, y3f(x-1), x-0, x-3)
        val left-path2  = PolyLinePath(`left-path2, time, square-path, 4.0f)
        val right-path2 = PolyLinePath(`right-path2, time, square-path, 4.0f)
        sched = dof-sched{_, time, left-path1, right-path1, left-path2, right-path2}
        DOF(`main, time, robot-simple-body-exp-spec5, left-path1, left-path2, right-path1, right-path2)
      "time-dancer-two-paths" :
        sched = two-paths-sched{_, x-0, x-1}
        val left-path  = PolyLinePath(`left-path,  time, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        val right-path = PolyLinePath(`right-path, time, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-simple-path" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        TimeExpKinematicsSimplePath(`main, time, robot-arm-exp-spec, path, `hand)
      "time-dancer-square" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-cube" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(x-0)) $ cube-path, 8.0f)
        TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-uing" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-two-rnds" :
        val left-path = OrbitParticle(`left-particle, time, V3f(-8.0f, x-1, 5.0f), x-0, 2.0f)
        val right-path = OrbitParticle(`right-particle, time, V3f(8.0f, x-1, 5.0f), x-0, 4.0f)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-two-orbit2s" :
        val left-path = Orbit2Particle(`left-particle, time, y3f(x-1), x-0, x-1, 0.25f, 3.0f)
        val right-path = Orbit2Particle(`right-particle, time, y3f(x-1), x-0, x-1, 0.25f, 3.0f)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-rnd" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, x-3)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        ; sched = rnd-sched{_, x-0, x-1}
        TimeExpKinematicsPathCenter(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-grounded" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, x-3)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathGrounded(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-tied" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, x-3)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathTied(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-cuffed" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, x-3)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathCuffed(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-trace" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, x-2)
        TimeExpKinematicsPathTrace(`main, x-3, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-bind" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, x-2)
        TimeExpKinematicsPathBind(`main, x-3, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-fall" :
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j5, `bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathFall(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          bottom-joints, left-joints, right-joints)
      "time-dancer-gyrate" :
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j5, `bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathGyrate(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          bottom-joints, left-joints, right-joints)
      "test-joint" :
        TimeExpKinematicsTestJoint(`main, n-0, time, robot-simple-body-exp-spec5)
      "time-dancer-rnd-orbit2" :
        val path = Orbit2Particle(`particle, time, y3f(x-1), x-0, x-1, 4.0f, 1.0f)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathCenter(`main, x-0, x-2, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-one-path" :
        val left-path = OrbitParticle(`left-path, time, y3f(x-1), x-0, 3.0f)
        val path-speed = SymVar(`path-speed, 1.0f, false, false)
        val right-path = PolyLinePath(`right-path, time, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 1.0f)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        sched = one-path-sched{_, right-joints, left-path, x-0, x-1}
        TimeExpKinematicsPathCenterStraighten(`main, x-0, time, robot-simple-body-exp-spec5,
           bottom-joints, left-joints, right-joints, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-rnd-base" :
        val path = OrbitParticle(`particle, time, y3f(x-1), x-0, 3.0f)
        TimeExpKinematicsPathCenterBase(`main, x-0, x-2, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-rnd-sphere" :
        val path = OrbitParticle(`particle, time, y3f(x-1), 5.0f,  1.0f)
        TimeExpKinematicsPathSphere(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j2, `left-j4, `right-j4)
      ; "time-dancer-curl" :
      ;   TimeExpKinematicsCurl(`main, x-0, time, robot-simple-body-exp-spec5)
      ; "time-dancer-seq" :
      ;   val path1 = PolyLinePath(`path1, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
      ;   val path2 = PolyLinePath(`path2, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 6.0f)
      ;   val paths = [20.0f => path1, 20.0f => path2]
      ;   TimeExpKinematicsPaths(`main, x-0, time, robot-simple-body-exp-spec5, paths, `right-j4)
      "time-dancer-hulu" :
        val left-path = PolyLinePath(`left-path, time, mov-y(x-1) $ mov-x(-8.0f) $ reflect-xz $ mag(xyz(x-0)) $ circle-line, 4.0f * x-2)
        val right-path = PolyLinePath(`right-path, time, mov-y(x-1) $ mov-x(8.0f) $ reflect-xz $ mag(xyz(x-0)) $ circle-line, 3.0f * x-2)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-twist" :
        val left-path = PolyLinePath(`left-path, time, mov-y(x-1) $ reflect-x $ reflect-yz $ mag(xyz(x-0)) $ round-you, x-2)
        val right-path = PolyLinePath(`right-path, time, mov-y(x-1) $ reflect-yz $ mag(xyz(x-0)) $ round-you, x-2)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-uing-wrist" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPathWrist(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4, `right-l3)
      "time-dancer-uing-straight" :
        val path = PolyLinePath(`path, time, mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPathStraight(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4, `right)
      "time-dancer-uing-straighten" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPathStraighten(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-uing-mirror" :
        val path = PolyLinePath(`path, time,  mov-y(x-1) $ mag(xyz(2.0f * x-0)) $ round-you, 16.0f)
        TimeExpKinematicsMirror(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-uing-reflect" :
        val path = PolyLinePath(`path, time, mov-y(x-1) $ mag(xyz(2.0f * x-0)) $ round-you, 16.0f)
        TimeExpKinematicsReflect(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-uing-circle" :
        val path = PolyLinePath(`path, time, mov-z(2.0f) $ mov-y(x-1) $ mag(xyz(2.0f * x-0)) $ round-you, 16.0f)
        TimeExpKinematicsCircle(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-bounce" :
        TimeExpKinematicsBounce(`main, x-0, time, robot-simple-body-exp-spec5, `left-j4, `right-j4)
      ; "time-leg" : TimeLeg(`main, x-0, time)
      else : LineBody(`line, 7.0f)

  ; println("RUNNING MODULE...")

  ; for item in sphere-excludes do :
  ;   println("%_ = %_" % [key(item), value(item)])

  val mod = next(filter-by<KinematicsExpBody>(all-children(m)))

  val sphere-excludes = to-hashtable<Symbol,Tuple<Symbol>> $ for item in vertex-collision-excludes(mod) seq :
    vertex-to-sphere-name(key(item)) => to-tuple $ seq(vertex-to-sphere-name, value(item))
  
  defn collision-detection () :
    for s in spheres(mod) do :
      set-color(s, xyz(1.0f))
    for s1 in spheres(mod) do :
      ; println("  %_" % [id(s1)])
      for s2 in spheres(mod) do :
        if not contains?(sphere-excludes[id(s1)], id(s2)) :
          val collides? = distance(pos(center(s1)), pos(center(s2))) < (2.0f * x(radius(s1)))
          ; println("    %_ = %_" % [id(s2), collides?])
          if collides? :
            println("COLLIDE %_ %_" % [id(s1), id(s2)])
            set-color(s1, x3f(1.0f))
        
  run-module(m, time, DanceScheduler{_, sched, x-0, x-1, collision-detection})  

defn demo (top-name:String) :
  demo(top-name, top-n-0, top-n-1, top-n-2, top-x-0, top-x-1, top-x-2, top-x-3)

defn main () :
  parse-args(screen-props, command-line-arguments())
  val seed = current-time-us() when (top-seed < 0) else to-long(top-seed)
  println("SEED = %_" % [seed]) when top-seed < 0
  RANDOM = Random(seed)
  demo(top-name)  

main()

