defpackage constraints-kinematics-app :
  import core
  import math
  import collections
  import utils/file-system
  import utils/math
  import utils/rnd
  import utils/seqable
  import geom/vec
  import geom/mat
  import geom/angle
  import geom/shape
  import geom/bounded
  import geom/poseable
  import geom/line-segment
  import geom/polygon
  import geom/polyline
  import geom/line-loop
  import geom/box
  import geom/polyhedron
  import geom/polyhedra
  import gui/props
  import gui/lay
  import gui/viz
  import gfx/gl
  import gfx/glfw
  import geom/gfx
  import gfx/drawing
  import calculus
  import constraints
  import constraints-paths
  import constraints-viz

defstruct LinkSpec :
  name : Symbol
  len : Float
  ; start : Symbol
  ; end : Symbol

; defn vertices (spec:LinkSpec) -> Tuple<Symbol> :
;   [start(spec), end(spec)]
; 
; defn connected? (spec:LinkSpec, vertex:Symbol) -> True|False :
;   start(spec) == vertex or end(spec) == vertex
; 
; defn other (spec:LinkSpec, vertex:Symbol) -> Symbol :
;   start(spec) when end(spec) == vertex else end(spec)

; defenum LinkSide :
;   LinkStart
;   LinkEnd
; 
; defstruct LinkVertexSpec :
;   link : Symbol
;   side : LinkSide

defenum JointKind :
  HingeJoint
  RotaryJoint

defstruct JointSpec :
  name : Symbol
  ; axis : Int
  ; limits : Box1f
  kind: JointKind
  link0 : Symbol
  link1 : Symbol

defn connected? (spec:JointSpec, link:Symbol) -> True|False :
  link0(spec) == link or link1(spec) == link

defn other (spec:JointSpec, link:Symbol) -> Symbol :
  link0(spec) when link1(spec) == link else link1(spec)

defmulti joint-angle (kind:JointKind, l0:Link, l1:Link) -> Angle 
defmulti joint-cost (kind:JointKind, l0:Link, l1:Link) -> Exp

defstruct KinematicsSpec :
;  root : Symbol
  links : Tuple<LinkSpec>
  joints : Tuple<JointSpec>

; defn vertices (spec:KinematicsSpec) -> Seqable<Symbol> :
;   unique $ for link in links(spec) seq-cat : [start(link), end(link)]
; 
; defn links-of (spec:KinematicsSpec, vertex:Symbol) -> Seqable<LinkSpec> :
;   for link in links(spec) filter : connected?(link, vertex)

defstruct Link <: Module :
  id : Symbol with: (as-method => true)
  init-len : Float
  rnd-radius : Float with: (default => 1.0f)
  len : Const with: (init => Const(init-len))
  a : Vertex with: (init => Vertex(`a, false, V3f( -5.0f, 0.0f) + rnd-radius * V3f(rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f)), false))
  b : Vertex with: (init => Vertex(`b, false, V3f(  5.0f, 0.0f) + rnd-radius * V3f(rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f)), false))
  c : Vertex with: (init => Vertex(`c, true,  V3f( -5.0f, 0.0f, 5.0f) + rnd-radius * V3f(rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f), rndf(-1.0f, 1.0f)), false))
  y : Edge with: (init => Edge(`y, a, b))
  z : Edge with: (init => Edge(`z, a, c, true, false))
  ang : Angle with: (init => ConnectedAngle(`abc, y, z, true))
  entities : Tuple<Entity> with: (as-method => true, init => [a, b, c, y, z, ang])
  cost : Exp with: (as-method => true, init =>
    EdgeLengthConstraint( exp(y), len) + OrthogonalConstraint(exp(y), exp(z))) ;AngleConstraint(ang, Const(PI-F / 2.0f)))

defmethod joint-angle (kind:HingeJoint, l0:Link, l1:Link) : 
  Angle(`ang, b(l0), a(l0), a(l1), b(l1), true)

defmethod joint-cost (kind:HingeJoint, l0:Link, l1:Link) :
  ; OrthogonalConstraint(exp(z(l0)), exp(z(l1)))
  ParallelConstraint(exp(z(l0)), exp(z(l1)))

defmethod joint-angle (kind:RotaryJoint, l0:Link, l1:Link) :
  Angle(`ang, z(l0), z(l1), true)

defmethod joint-cost (kind:RotaryJoint, l0:Link, l1:Link) :
  ParallelConstraint(exp(y(l0)), exp(y(l1)))

defstruct Joint <: Module :
  id : Symbol with: (as-method => true)
  kind : JointKind
  l0 : Link
  l1 : Link
  ang : Angle with: (init => joint-angle(kind, l0, l1))
  entities : Tuple<Entity> with: (as-method => true, init => [ang])
  cost : Exp with: (as-method => true, init =>
    joint-cost(kind, l0, l1) +
    SameVertexConstraint( [ b(l0), a(l1) ])
    )

defstruct KinematicsBody <: Module :
  id : Symbol with: (as-method => true)
  specs : KinematicsSpec
  link-table : HashTable<Symbol,Link> with: (init => HashTable<Symbol,Link>())
  links : Tuple<Link> with: (init => to-tuple $ for spec in links(specs) seq :
    val link = make-instance(name(spec), Link{_, len(spec)})
    println("link %_" % [name(spec)])
    link-table[name(spec)] = link
    link)
  joints : Tuple<Joint> with: (init => to-tuple $ for spec in joints(specs) seq :
    val l0 = link-table[link0(spec)]
    val l1 = link-table[link1(spec)]
    println("joint %_" % [name(spec)])
    make-instance(name(spec), Joint{_, kind(spec), l0, l1}))
  entities : Tuple<Entity> with: (as-method => true, init => to-tuple $ cat(links, joints))
  cost : Exp with: (as-method => true, init => Const(0.0f))

defn joints (spec:KinematicsSpec, link:Symbol) -> Seqable<JointSpec> :
  for joint in joints(spec) filter : connected?(joint, link)

;;; KINEMATICS EXP

defstruct LinkExpSpec :
  name : Symbol
  node0 : Symbol
  node1 : Symbol
  len : Float
with:
  printer => true

defstruct JointExpSpec :
  name : Symbol
  axis : Int
  limits : Box1f
  link0 : Symbol
  link1 : Symbol
with:
  printer => true

val default-limits = Box1f((- PI-F), PI-F)
; val default-limits = Box1f(-0.5f * PI-F, 0.5f * PI-F)
; val default-limits = Box1f(0.0f * PI-F, 0.0f * PI-F)

defn connected? (spec:LinkExpSpec, node:Symbol) -> True|False :
  node0(spec) == node or node1(spec) == node

defn other (spec:LinkExpSpec, node:Symbol) -> Symbol :
  node0(spec) when node1(spec) == node else node1(spec)

defn connected? (spec:JointExpSpec, link:Symbol) -> True|False :
  link0(spec) == link or link1(spec) == link

defn other (spec:JointExpSpec, link:Symbol) -> Symbol :
  link0(spec) when link1(spec) == link else link1(spec)

defstruct KinematicsExpSpec :
  root : Symbol
  links : Tuple<LinkExpSpec>
  joints : Tuple<JointExpSpec>
with:
  printer => true

defn KinematicsExpSpec (root:Symbol, i-links-and-joints:Seqable<LinkExpSpec|JointExpSpec>) -> KinematicsExpSpec :
  val lj = to-tuple $ i-links-and-joints
  KinematicsExpSpec(
    root,
    to-tuple $ filter-by<LinkExpSpec>(lj), 
    to-tuple $ filter-by<JointExpSpec>(lj))

defn links-with-node (spec:KinematicsExpSpec, node:Symbol) -> Seq<LinkExpSpec> :
  for link in links(spec) filter : connected?(link, node)    

defn mov-y-mat-exp (del:Exp) -> MatExp :
  mov-mat-exp(Vec3Exp(Const(0.0f), del, Const(0.0f)))

defstruct LinkExp <: Entity :
  id : Symbol with: (as-method => true)
  len : Float
  edge : Edge         ; points to two 
  axis : Int
  angle : SymVar
  limits : Box1f
  pose : SimplePoseExp
  ; local-mat : MatExp
  global-mat : Mat

defmethod draw (e:LinkExp, size:Float) :
  gl-color3f(1.0f, 1.0f, 1.0f)
  gl-push-matrix()
  ; println("%_" % [value(global-mat(e))])
  gl-mult-matrix(value(global-mat(e)))
  ; gl-mult-matrix(id-mat44f())
  gl-translatef(0.0f, -0.5f * len(e), 0.0f)
  draw-rect3(0.5f, len(e), 1.0f)
  gl-pop-matrix()

defmethod vars (e:LinkExp) -> Seqable<AnyVar> :
  cat(vars(edge(e)), [angle(e)])

defn init-edges (id:Symbol, spec:KinematicsExpSpec, vertices:HashTable<Symbol,Vertex>) -> HashTable<Symbol,LinkExp> :
  val link-specs = to-hashtable<Symbol, LinkExpSpec> $
    for l in links(spec) seq : name(l) => l
  val joint-specs = to-hashtable<[Symbol,Symbol], JointExpSpec> $
    for j in joints(spec) seq-cat : [[link0(j),link1(j)] => j, [link1(j),link0(j)] => j]
  val link-nbrs = HashTable<Symbol, List<Symbol>>(List())
  for joint in joints(spec) do :
    link-nbrs[link0(joint)] = cons(link1(joint), link-nbrs[link0(joint)])
    link-nbrs[link1(joint)] = cons(link0(joint), link-nbrs[link1(joint)])

  ; println(spec)
  println(to-tuple $ link-nbrs)

  val visited-links? = HashSet<Symbol>()
  val origin = Vertex(root(spec), false, V3f(0.0f, 0.0f, 0.0f), true)
  vertices[root(spec)] = origin
  val link-exps = HashTable<Symbol,LinkExp>()
  let loop (from-link-name:False|Symbol = false, from-vertex:Vertex = origin, from-global-mat:MatExp = mov-mat-exp(exp(origin))) :
    println("FROM-LINK %_ FROM-VERTEX %_" % [from-link-name, name(from-vertex)])
    for to-link-spec in links-with-node(spec, name(from-vertex)) do :
      val to-link-name = name(to-link-spec)
      if not visited-links?[to-link-name] :
        println(">>> WALKING LINK %_" % [to-link-name])
        add(visited-links?, to-link-name)
        val [axis, angle, limits] =
          match(from-link-name:Symbol) :
            val joint-spec = joint-specs[[from-link-name, to-link-name]]
            val angle-value = rnd(limits(joint-spec))
            println("%_ %_ = %_" % [name(joint-spec), limits(joint-spec), radians-to-degrees(angle-value)])
            val angle = SymVar(name(joint-spec), angle-value, limits(joint-spec)) 
            [axis(joint-spec), angle, limits(joint-spec)]
          else :
            [2, SymVar(`root, 0.0f, false), Box1f(0.0f, 0.0f)]
        val pose = SimplePoseExp(Vec3Exp(Const(0.0f), Const(len(to-link-spec)), Const(0.0f)), axis, exp(angle))
        val to-local-mat = to-mat-exp(pose)
        val to-global-mat = to-local-mat * from-global-mat
        val to-global-mat-vars = Mat(to-link-name, to-global-mat)
        val to-vertex-name = other(to-link-spec, name(from-vertex))
        val to-vertex = Vertex(to-vertex-name, to-global-mat * Const(V3f(0.0f, 0.0f, 0.0f)))
        vertices[to-vertex-name] = to-vertex
        val edge = Edge(to-link-name, from-vertex, to-vertex)
        val to-link-exp = LinkExp(to-link-name, len(to-link-spec), edge, axis, angle, limits, pose, to-global-mat-vars) ; to-local-mat, 
        link-exps[to-link-name] = to-link-exp
        loop(to-link-name, to-vertex, to-global-mat)
        println("<<< WALKED LINK %_" % [to-link-name])

  ; println(to-tuple $ link-exps)
  ; println(to-tuple $ vertices)

  link-exps

defstruct KinematicsExpBody <: Module :
  id : Symbol with: (as-method => true)
  specs : KinematicsExpSpec
  vertex-table : HashTable<Symbol,Vertex> with: (init => HashTable<Symbol,Vertex>())
  link-table : HashTable<Symbol,LinkExp> with: (init => init-edges(id, specs, vertex-table))
  entities : Tuple<Entity> with: (as-method => true, init =>
    to-tuple $ cat-all $ [values(vertex-table), for l in values(link-table) seq-cat : [l, angle(l), edge(l), global-mat(l)]])
  cost : Exp with: (as-method => true, init => Const(0.0f))

defstruct KinematicsExpBody2 <: Module :
  id : Symbol with: (as-method => true)
  len : Const with: (init => Const(5.0f))
  s : SymVar with: (init => SymVar(`s, PI-F / 4.0f))
  t : SymVar with: (init => SymVar(`t, PI-F / 2.0f))
  a : Vertex with: (init => Vertex(`a, false, V3f(0.0f, 0.0f, 0.0f), false))
  b : Vertex with: (init => Vertex(`b, exp(a) + len * Vec3Exp(cos(exp(s)), sin(exp(s)), Const(0.0f))))
  c : Vertex with: (init => Vertex(`c, exp(b) + len * Vec3Exp(cos(exp(t)), sin(exp(t)), Const(0.0f))))
  ab : Edge with: (init => Edge(`ab, a, b))
  bc : Edge with: (init => Edge(`bc, b, c))
  entities : Tuple<Entity> with: (as-method => true, init => [s, t, a, b, c, ab, bc])
  ; cost : Exp with: (as-method => true, init => SameVecConstraint([ exp(c) Vec3Exp(Const(-1.0f), Const(1.0f), Const(0.0f))]))
  ; cost : Exp with: (as-method => true, init => SameConstraint(exp(y(c)) Const(0.0f)))
  ; cost : Exp with: (as-method => true, init => SameConstraint(exp(x(c)) Const(-2.0f)))
  cost : Exp with: (as-method => true, init => Const(0.0f))

defn TimeKinematics (name:Symbol, radius:Float, time:SymVar) -> BindBody :
  val path = PolyLinePath(`path, mag(xyz(radius)) $ square-path, 4.0f)
  BindBody(`tkb, KinematicsExpBody2(`tab),
           fn (m) : []
           fn (m) : cat-all $ [ [ c(m) => exp(point(path)) ] ]
           to-tuple $ cat-all $ seq(vars, [path]))

defn MixCost (id:Symbol, n:Symbol, g:Float, e:Exp) -> MixCost :
  MixCost(add-suffix(full-name(id), n), g, e)

defn MixCost (id:Symbol, n:Symbol, e:Exp) -> MixCost :
  MixCost(id, n, 1.0f, e)

defn centering (m:KinematicsExpBody, do-center:(Tuple<Vec3Exp>, Vec3Exp) -> Exp, center:Vec3Exp) -> Exp :
  do-center(to-tuple $ seq(exp, values(vertex-table(m))), center)

defn centering (m:KinematicsExpBody) -> Exp :
  centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))

defn curl-angle (a:Exp) -> Exp :
  defn curl (a:Exp) : exp(Const(-1.0f) * a * a)
  Const(100.0f) * curl(Const(1.5f / PI-F) * a)

defn curl-angles (m:KinematicsExpBody) -> Exp :
  ; sum $ seq(fn (l) : curl-angle(angle(l)), for l in values(link-table(m)) filter : axis(l) == 2)
  sum $ seq(fn (l) : curl-angle(exp(angle(l))), values(link-table(m)))

defn limit-angle (a:Exp) -> Exp :
  defn limit (a:Exp) : exp(a * a)
  ; limit(Const(3.0f / PI-F) * a)
  limit(Const(2.0f / PI-F) * a)

defn limit-angles (m:KinematicsExpBody) -> Exp :
  ; sum $ seq(fn (l) : limit-angle(angle(l)), for l in values(link-table(m)) filter : axis(l) == 2)
  sum $ seq(fn (l) : limit-angle(exp(angle(l))), values(link-table(m)))

defn straighten (m:KinematicsExpBody) -> Exp :
  ; sum $ seq(fn (l) : exp(angle(l)) * exp(angle(l)), for l in values(link-table(m)) filter : axis(l) == 2)
  sum $ seq(fn (l) : exp(angle(l)) * exp(angle(l)), values(link-table(m)))

defn fall (m:KinematicsExpBody, tips:Tuple<Symbol>, target:Float) -> Exp :
  ; sum $ seq(fn (l): sqerr(Const(target) - y(exp(v1(edge(l))))), values(link-table(m)))
  sum $ seq(fn (tip): sqerr(Const(target) - y(exp(vertex-table(m)[tip]))), tips)

defn above (m:KinematicsExpBody, tips:Tuple<Symbol>, target:Float) -> Exp :
  sum $ seq(fn (tip): logistic(Const(target) - y(exp(vertex-table(m)[tip]))), tips)

defn fall (m:KinematicsExpBody, tips:Tuple<Symbol>, target:V3f) -> Exp :
  ; sum $ seq(fn (l): (println(name(v1(edge(l)))), sqerr(Const(target) - exp(y(v1(edge(l)))))), values(link-table(m)))
  sum $ seq(fn (tip): SameConstraint(exp(vertex-table(m)[tip]), Const(target)), tips)

defn basing (m:KinematicsExpBody, origin:Float) -> Exp :
  Const(10.0f) * SameVecConstraint([exp(vertex-table(m)[root(specs(m))]) Const(V3f(0.0f, origin, 0.0f))])

defn repel (v1:Vec3Exp, v2:Vec3Exp, d:Exp) -> Exp :
  val x = distance2(v1, v2)
  d * exp(Const(-1.0f) * x)

defn repel (v1:Vertex, v2:Vertex, d:Exp) -> Exp :
  repel(exp(v1), exp(v2), d)

defn TimeExpKinematics (name:Symbol, time:SymVar, spec:KinematicsExpSpec, new-entities:Seqable<Entity>,
                        new-constraints:(KinematicsExpBody, HashTable<Symbol,Vertex>) -> Seqable<MixCost>) -> BindBody :
  val m = KinematicsExpBody(`main, spec)
  BindBody(name, m,
           cat([ MixCost(name, `basing, basing(m, -10.0f))], new-constraints(m, vertex-table(m))),
           to-tuple $ cat-all $ seq(vars, new-entities), new-entities)

defn TimeExpKinematicsRepel (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ ],
    fn (m, verts) : [
      MixCost(name, `repel, repel(verts[left-tip], verts[right-tip], Const(2.0f))) ])

defn TimeExpKinematicsPath (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m)), MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

defn TimeExpKinematicsSimplePath (name:Symbol, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

defn all-repels (name:Symbol, verts:HashTable<Symbol, Vertex>) -> Seqable<MixCost> :
  if top-collision-detection? :
    val vert-names = to-tuple $ keys(verts)
    println(vert-names)
    for i in 0 to length(verts) seq-cat :
      for j in (i + 1) to length(verts) seq :
        MixCost(name, symbol-join $ [`repel "-" i "-" j], repel(verts[vert-names[i]], verts[vert-names[j]], Const(8.0f)))
  else :
    []

defn TimeExpKinematicsTwoPaths (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
                                left-path:Path, left-tip:Symbol, right-path:Path, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ left-path, right-path ],
    fn (m, verts) :
      val vert-names = to-tuple $ keys(verts)
      cat-all $ [[
        MixCost(name, `centering, centering(m)),
        MixCost(name, `limit, limit-angles(m)),
        ; MixCost(name, `touch, Const(0.5f), DistanceConstraint(verts[right-tip], verts[left-tip], Const(1.0f)))
        MixCost(name, `left-path,  SameConstraint(exp(verts[left-tip]),  exp(point(left-path))))
        MixCost(name, `right-path, SameConstraint(exp(verts[right-tip]), exp(point(right-path))))
        ]
        all-repels(name, verts)
      ]
)

defn TimeExpKinematicsPathCenter
    (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
     origin-joint:Symbol, bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val target = SymVar(add-suffix(name, `target), 0.0f, false, false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  val knee = bottom-joints[2]
  val mid = origin-joint
  TimeExpKinematics(name, time, spec, [ path, target ], fn (m, verts) :
    cat-all $ [[
      ; ; trace with other hand
      ; MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(path)))
      ; MixCost(name, `trace/x, SameConstraint(exp(verts[left-tip]), Vec3Exp(x(exp(verts[right-tip])), Const(-5.0f), z(exp(verts[right-tip])))))
      ; MixCost(name, `centering, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      ; MixCost(name, `limit, limit-angles(m)),
      ; MixCost(name, `above, 10.0f, above(m, joints, -8.0f))
      ; bondage with both hands on ground
      MixCost(name, `path, SameConstraint(exp(verts[mid]), exp(point(path))))
      MixCost(name, `trace/y, SameConstraint(y(exp(verts[left-tip])), Const(-8.0f)))
      MixCost(name, `trace/y, SameConstraint(y(exp(verts[right-tip])), Const(-8.0f)))
      MixCost(name, `centering, centering(m, CenterXZConstraint, Const(V3f(0.0f, 0.0f, 0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `above, 10.0f, above(m, joints, -8.0f))
      ; ; bondage with arms behind
      ; MixCost(name, `centering, centering(m, CenterConstraint, Const(V3f(0.0f, -4.0f, 0.0f)))),
      ; MixCost(name, `limit, limit-angles(m)),
      ; MixCost(name, `touch, SameConstraint(exp(verts[left-tip]), exp(verts[right-tip])))
      ; MixCost(name, `path, SameConstraint(exp(verts[mid]), exp(path)))
      ; MixCost(name, `above, 10.0f, above(m, joints, -8.0f))
      ; ;bondage
      ; MixCost(name, `touch, DistanceConstraint(verts[left-tip], verts[knee], Const(1.0f)))
      ; MixCost(name, `touch, DistanceConstraint(verts[right-tip], verts[knee], Const(1.0f)))
      ; MixCost(name, `path, SameConstraint(exp(verts[mid]), exp(path)))
      ; ;tips tied
      ; MixCost(name, `touch, SameConstraint(exp(verts[left-tip]), exp(verts[right-tip])))
      ; MixCost(name, `sphere, DistanceConstraint(exp(verts[right-tip]), exp(verts[left-tip]), exp(target)))
      ; MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(path)))
      ; MixCost(name, `above, 10.0f, above(m, joints, -8.0f))
      ; MixCost(name, `reflect, SameConstraint(reflect-y-mat-exp() * reflect-x-mat-exp() * exp(verts[right-tip]), exp(verts[left-tip])))
      ]
      all-repels(name, verts)
      ])

defn TimeExpKinematicsPathCenterStraighten
    (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
     bottom-joints:Tuple<Symbol>, left-joints:Tuple<Symbol>, right-joints:Tuple<Symbol>,
     left-path:Path, left-tip:Symbol, right-path:Path, right-tip:Symbol) -> BindBody :
  val center-vertex = Vertex(add-suffix(name, `center), true, xyz(0.0f), false)
  val joints = to-tuple $ cat-all $ [bottom-joints left-joints right-joints]
  TimeExpKinematics(name, time, spec, [ left-path, right-path, center-vertex ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, exp(center-vertex))),
      MixCost(name, `limit, limit-angles(m)),
      MixCost(name, `straighten, straighten(m))
      ; MixCost(name, `fall, fall(m, joints, -8.0f))
      ; MixCost(name, `fall, fall(m, [right-tip], -8.0f))
      MixCost(name, `on-line-right, OnLineConstraint(exp(verts[right-tip]), Const(V3f(-1.0f, 0.0f, 4.0f)), Const(V3f(1.0f, 0.0f, 4.0f)), Const(0.0f)))
      MixCost(name, `fall-right, fall(m, [right-tip], -8.0f))
      MixCost(name, `fall-left, fall(m, [left-tip], -8.0f))
      MixCost(name, `fall, centering(m, CenterConstraint, Const(V3f(0.0f, -10.0f, 0.0f)))),
      MixCost(name, `above, 10.0f, above(m, joints, -10.0f))
      ; MixCost(name, `fall, fall(m, [left-tip, right-tip], V3f(0.0f, -8.0f, 0.0f)))
      ; MixCost(name, `fall, SameConstraint(y(exp(verts[left-tip])), Const(-8.0f)) + SameConstraint(y(exp(verts[right-tip])), Const(-8.0f)))
      MixCost(name, `left-path, SameConstraint(exp(verts[left-tip]), exp(point(left-path))))
      MixCost(name, `right-path, SameConstraint(exp(verts[right-tip]), exp(point(right-path)))) ]
      ; for j in right-joints seq :
      ;   MixCost(name, symbol-join([`touch "/" j]), SameConstraint(exp(verts[left-tip]), exp(verts[j])))
      all-repels(name, verts)
      ])

defn TimeExpKinematicsPathCenterBase (name:Symbol, radius:Float, target:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val c = Const(xyz(0.0f))
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) :
    cat-all $ [[
      MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
      MixCost(name, `limit, limit-angles(m)),
      ; MixCost(name, `base, SameConstraint(exp(y(verts[right-tip])), Const(target)))
      ; MixCost(name, `sphere, DistanceConstraint(exp(verts[right-tip]), c, Const(target)))
      MixCost(name, `path, SameConstraint(exp(verts[left-tip]), exp(point(path)))) ]
      all-repels(name, verts)
      ])

defn TimeExpKinematicsPathSphere (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val c = Const(xyz(0.0f))
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) : [
    (for v in verts do : println(key(v)), MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))))
    MixCost(name, `limit, limit-angles(m)),
    MixCost(name, `left-sphere, DistanceConstraint(exp(verts[left-tip]), c, Const(radius)))
    MixCost(name, `right-sphere, DistanceConstraint(exp(verts[right-tip]), c, Const(radius)))
    MixCost(name, `reflect, SameConstraint(reflect-y-mat-exp() * reflect-x-mat-exp() * exp(verts[right-tip]), exp(verts[left-tip])))
    MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

; defn TimeExpKinematicsPaths (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec,
;                              paths:Tuple<KeyValue<Float, Vertex>>, tip:Symbol) -> BindBody :
;   TimeExpKinematics(name, time, spec, to-tuple $ cat([ time ], seq(value, paths)),
;     fn (m, verts) : to-tuple $ cat-all $ [ [ MixCost(name, `centering, centering(m), Const(xyz(0.0f))) ],
;       for ([s, e] in successive-pairs(cat([0.0f], cumsum(seq(key, paths)))), path in seq(value, paths), i in 0 to false) seq :
;         println("S %_ E %_ V %_" % [s, e, id(path)])
;         MixCost(name, symbol-join([`path, i]), pulse(exp(time), Const(s), Const(e)), SameConstraint(exp(verts[tip]), exp(path))) ])
; 
; defn TimeExpKinematicsCurl (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec) -> BindBody :
;   TimeExpKinematics(name, time, spec, [ time ],
;     fn (m, verts) : to-tuple $ cat-all $ [ [
;       MixCost(name, `centering,  centering(m), Const(xyz(0.0f))),
;       MixCost(name, `limit,      limit-angles(m)) ]
;       for i in 0 to 4 seq-cat :
;         val o = to-float(i) * 20.0f
;         [ MixCost(name, symbol-join([`curl i]),       pulse(exp(time), Const(o +  0.0f), Const(o + 10.0f)), curl-angles(m)),
;           MixCost(name, symbol-join([`straighten i]), pulse(exp(time), Const(o + 10.0f), Const(o + 20.0f)), straighten(m)) ],
;       ])

defn TimeExpKinematicsPathStraighten (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ], fn (m, verts) : [
    MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
    MixCost(name, `straighten, 0.1f, straighten(m)),
    MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ])

defn TimeExpKinematicsCircle (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val r = SymVar(`radius, 1.0f * radius, false)
  val circ  = Circle(`circle, Vertex(`center, V3f(0.0f, 0.0f, -4.0f)), r, true, false)
  TimeExpKinematics(name, time, spec, [ path, circ, r ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m)),
      MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(point(path))))
      MixCost(name, `circle, ProjectOntoCircle(verts[left-tip], circ)) ])

defn TimeExpKinematicsPathWrist (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol, wrist:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m)), 
      MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path))))
      MixCost(name, `horizontal, HorizontalConstraint(exp(edge(link-table(m)[wrist])))) ])

defn TimeExpKinematicsPathStraight (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, tip:Symbol, side:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) :
      val links = to-tuple $ for entry in link-table(m) filter :
        prefix?(to-string(key(entry)), to-string(side)) and axis(value(entry)) == 2
      cat-all $ [ [ MixCost(name, `centering, centering(m, CenterConstraint, Const(xyz(0.0f)))),
                    MixCost(name, `path, SameConstraint(exp(verts[tip]), exp(point(path)))) ]
        for (link in links, i in 0 to false) seq :
          MixCost(name, symbol-join([`link, i]), 4.0f, SameConstraint(exp(angle(value(link))), Const(0.0f))) ] )

defn TimeExpKinematicsReflect (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m))
     MixCost(name, `reflect, SameConstraint(reflect-y-mat-exp() * reflect-x-mat-exp() * exp(verts[right-tip]), exp(verts[left-tip])))
     MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(point(path)))) ])

defn TimeExpKinematicsMirror (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, path:Path, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  TimeExpKinematics(name, time, spec, [ path ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m))
      MixCost(name, `mirror, SameConstraint(
       mov-mat-exp(Const(y3f(20.0f))) * mag-mat-exp(0.5f) * exp(verts[right-tip]),
       exp(verts[left-tip])))
      MixCost(name, `path, SameConstraint(exp(verts[right-tip]), exp(point(path)))) ])

defn TimeExpKinematicsBounce (name:Symbol, radius:Float, time:SymVar, spec:KinematicsExpSpec, left-tip:Symbol, right-tip:Symbol) -> BindBody :
  val path1 = (reflect-xy-mat-exp() * bounce(24.0f, 2.0f, time)) + Const(V3f(0.0f, 8.0f, 0.0f))
  ; val path1 = bounce(12.0f, 2.0f, time) + Const(V3f(-8.0f, 4.0f, 0.0f))
  val path2 = bounce(4.0f, 0.5f, time)  + Const(V3f(0.0f,  2.0f, 0.0f))
  ; val path2 = bounce(3.0f, 1.0f, time) + exp(vertex-table(m)[`origin]) - Const(V3f(0.0f, 1.5f, 0.0f))
  TimeExpKinematics(name, time, spec, [ time ],
    fn (m, verts) : [ MixCost(name, `centering, centering(m))
      MixCost(name, `limit,      limit-angles(m))
      MixCost(name, `path, SameConstraint(exp(verts[right-tip]), path1))
      MixCost(name, `bounce, SameConstraint(y(exp(verts[`origin])), y(path2))) ])

defn TimeLeg (name:Symbol, radius:Float, time:SymVar) -> BindBody :
  val path = PolyLinePath(`path, mag(xyz(radius)) $ square-path, 4.0f)
  val body = KinematicsBody(`main, robot-leg-spec)
  BindBody(`tkb, body,
           fn (m) : []
           fn (m) : cat-all $ [
             [ a(links(m)[0]) => Const(V3f(0.0f, 0.0f, 0.0f))
               b(last(links(m))) => exp(point(path)) ]
             ]
           to-tuple $ cat-all $ seq(vars, [path]))
      
val robot-arm-spec =
  KinematicsSpec([LinkSpec(`lower, 10.0f), LinkSpec(`upper, 10.0f)],
                 [JointSpec(`elbow, HingeJoint, `lower, `upper)])

val robot-leg-spec =
  KinematicsSpec([LinkSpec(`ankle, 5.0f), LinkSpec(`calf, 10.0f), LinkSpec(`thigh, 10.0f)],
                 [JointSpec(`ankle, RotaryJoint, `ankle, `calf), JointSpec(`knee, HingeJoint, `calf, `thigh)])

val robot-arm-spec0 =
  KinematicsSpec([LinkSpec(`lower, 10.0f)], [])

val robot-arm-exp-spec =
  KinematicsExpSpec(
    `shoulder,
    [LinkExpSpec(`fore-arm, `hand, `elbow, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `fore-arm, `upper-arm),
     LinkExpSpec(`upper-arm, `elbow, `shoulder, 10.0f)])

val robot-arm-exp-spec2 =
  KinematicsExpSpec(
    `torso,
    [LinkExpSpec(`fore-arm, `elbow,     `hand, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm),
     LinkExpSpec(`upper-arm, `shoulder, `elbow, 10.0f)
     JointExpSpec(`origin, 2, default-limits, `base, `upper-arm),
     LinkExpSpec(`base,      `torso,    `shoulder, 0.0f)
     ])

val robot-arm-exp-spec3 =
  KinematicsExpSpec(
    `origin,
    [LinkExpSpec(`hand, `wrist,     `finger, 5.0f),
     JointExpSpec(`wrist, 2, default-limits, `fore-arm, `hand),
     LinkExpSpec(`fore-arm, `elbow,     `wrist, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm),
     LinkExpSpec(`upper-arm, `shoulder, `elbow, 10.0f)
     JointExpSpec(`origin, 2, default-limits, `pivot, `upper-arm),
     LinkExpSpec(`pivot, `torso, `shoulder, 1.0f)
     JointExpSpec(`torso, 1, default-limits, `base, `pivot),
     LinkExpSpec(`base,      `origin,    `torso, 0.0f)
     ])

val open-manipulator-x-spec =
  KinematicsExpSpec(
    `origin,
    [LinkExpSpec(`hand, `wrist,     `finger, 14.66f),
     JointExpSpec(`wrist, 2, default-limits, `fore-arm, `hand),
     LinkExpSpec(`fore-arm, `elbow,     `wrist, 12.4f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm),
     LinkExpSpec(`upper-arm, `shoulder, `elbow, 12.8f)
     JointExpSpec(`origin, 2, default-limits, `pivot, `upper-arm),
     LinkExpSpec(`pivot, `torso, `shoulder, 4.6f)
     JointExpSpec(`torso, 1, default-limits, `base, `pivot),
     LinkExpSpec(`base,      `origin,    `torso, 3.0f)
     ])

val robot-leg-arm-exp-spec =
  KinematicsExpSpec(
    `foot,
    [LinkExpSpec(`ankle, `foot, `knee, 10.0f)
     JointExpSpec(`knee, 2, default-limits, `ankle, `thigh)
     LinkExpSpec(`thigh, `knee, `torso, 10.0f),
     JointExpSpec(`torso, 2, default-limits, `thigh, `upper-arm),
     LinkExpSpec(`upper-arm, `torso, `elbow, 10.0f),
     JointExpSpec(`elbow, 2, default-limits, `upper-arm, `fore-arm)
     LinkExpSpec(`fore-arm, `elbow, `hand, 10.0f)])

defn robot-arm (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base:Symbol) : symbol-join $ [side "-" base]
  [ LinkExpSpec(nameit(`upper-arm), `torso, nameit(`elbow), 10.0f),
    JointExpSpec(nameit(`elbow), 2, default-limits, nameit(`upper-arm), nameit(`fore-arm))
    LinkExpSpec(nameit(`fore-arm), nameit(`elbow), nameit(`hand), 10.0f) ]

defn robot-leg () -> Seqable<LinkExpSpec|JointExpSpec> :
  [ LinkExpSpec(`ankle, `foot, `knee, 10.0f),
    JointExpSpec(`knee, 2, default-limits, `ankle, `thigh)
    LinkExpSpec(`thigh, `knee, `torso, 10.0f) ]

val robot-simple-body-exp-spec =
  KinematicsExpSpec(`foot,
    cat-all $ [
      robot-arm(`left)
      robot-arm(`right)
      robot-leg()
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `thigh, `left-upper-arm)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `thigh, `right-upper-arm) ]
      ] )

; defn robot-arm2 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
;   defn nameit (base:Symbol) : symbol-join $ [side "-" base]
;   [LinkExpSpec(nameit(`base),      `origin,    nameit(`torso), 2.0f)
;    JointExpSpec(nameit(`torso), 1, default-limits, nameit(`base), nameit(`pivot)),
;    LinkExpSpec(nameit(`pivot), nameit(`torso), nameit(`shoulder), 4.0f)
;    JointExpSpec(nameit(`origin), 2, default-limits, nameit(`pivot), nameit(`upper-arm)),
;    LinkExpSpec(nameit(`upper-arm), nameit(`shoulder), nameit(`elbow), 8.0f)
;    JointExpSpec(nameit(`elbow), 2, default-limits, nameit(`upper-arm), nameit(`fore-arm)),
;    LinkExpSpec(nameit(`fore-arm), nameit(`elbow),     nameit(`wrist), 4.0f),
;    JointExpSpec(nameit(`wrist), 1, default-limits, nameit(`fore-arm), nameit(`hand)),
;    LinkExpSpec(nameit(`hand), nameit(`wrist),     nameit(`finger), 2.0f),
;    ]

defn robot-arm2 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base) : symbol-join $ [side "-" base]
  [LinkExpSpec(nameit("L0"), `origin,      nameit("J0"), 2.0f)
   JointExpSpec(nameit("J0"), 1, default-limits, nameit("L0"), nameit("L1")),
   LinkExpSpec(nameit("L1"), nameit("J0"), nameit("J1"), 4.0f)
   JointExpSpec(nameit("J1"), 2, default-limits, nameit("L1"), nameit("L2")),
   LinkExpSpec(nameit("L2"), nameit("J1"), nameit("J2"), 8.0f)
   JointExpSpec(nameit("J2"), 2, default-limits, nameit("L2"), nameit("L3")),
   LinkExpSpec(nameit("L3"), nameit("J2"), nameit("J3"), 4.0f),
   JointExpSpec(nameit("J3"), 1, default-limits, nameit("L3"), nameit("L4")),
   LinkExpSpec(nameit("L4"), nameit("J3"), nameit(`tip), 2.0f),
   ]

val robot-simple-body-exp-spec2 =
  KinematicsExpSpec(`bottom-tip,
    cat-all $ [
      robot-arm2(`left)
      robot-arm2(`right)
      robot-arm2(`bottom)
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-L0, `left-L0)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-L0, `right-L0) ]
      ] )

defn robot-arm3 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base:Symbol) : symbol-join $ [side "-" base]
  [LinkExpSpec(nameit(`base),      `origin,    nameit(`torso), 4.0f)
   JointExpSpec(nameit(`torso), 1, default-limits, nameit(`base), nameit(`upper-arm)),
   LinkExpSpec(nameit(`upper-arm), nameit(`torso), nameit(`elbow), 8.0f)
   JointExpSpec(nameit(`elbow), 2, default-limits, nameit(`upper-arm), nameit(`fore-arm)),
   LinkExpSpec(nameit(`fore-arm), nameit(`elbow),     nameit(`wrist), 8.0f),
   JointExpSpec(nameit(`wrist), 1, default-limits, nameit(`fore-arm), nameit(`hand)),
   LinkExpSpec(nameit(`hand), nameit(`wrist),     nameit(`finger), 4.0f),
   ]

val robot-simple-body-exp-spec3 =
  KinematicsExpSpec(`bottom-finger,
    cat-all $ [
      robot-arm3(`left)
      robot-arm3(`right)
      robot-arm3(`bottom)
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-base, `left-base)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-base, `right-base) ]
      ] )

defn robot-arm4 (side:Symbol) -> Seqable<LinkExpSpec|JointExpSpec> :
  defn nameit (base) : symbol-join $ [side "-" base]
  [LinkExpSpec(nameit("L0"), `origin,      nameit("J0"), 2.0f)
   JointExpSpec(nameit("J0"), 1, default-limits, nameit("L0"), nameit("L1")),
   LinkExpSpec(nameit("L1"), nameit("J0"), nameit("J1"), 2.0f)
   JointExpSpec(nameit("J1"), 2, default-limits, nameit("L1"), nameit("L2")),
   LinkExpSpec(nameit("L2"), nameit("J1"), nameit("J2"), 4.0f)
   JointExpSpec(nameit("J2"), 2, default-limits, nameit("L2"), nameit("L3")),
   LinkExpSpec(nameit("L3"), nameit("J2"), nameit("J3"), 4.0f),
   JointExpSpec(nameit("J3"), 2, default-limits, nameit("L3"), nameit("L4")),
   LinkExpSpec(nameit("L4"), nameit("J3"), nameit("J4"), 2.0f),
   JointExpSpec(nameit("J4"), 1, default-limits, nameit("L4"), nameit("L5")),
   LinkExpSpec(nameit("L5"), nameit("J4"), nameit(`tip), 2.0f),
   ]

val robot-simple-body-exp-spec4 =
  KinematicsExpSpec(`bottom-tip,
    cat-all $ [
      robot-arm4(`left)
      robot-arm4(`right)
      robot-arm4(`bottom)
      [ JointExpSpec(`left-hip, 2,  Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-L0, `left-L0)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-L0, `right-L0) ]
      ] )

defn robot-arm5 (nameit:(Symbol, Int) -> Symbol, links:Tuple<Float>, joints:Tuple<Int>) -> Seqable<LinkExpSpec|JointExpSpec> :
  val res = to-tuple $ cat-all $ [
    for (l in links, idx in 0 to false) seq :
      LinkExpSpec(nameit(`l, idx), nameit(`j, idx), nameit(`j, idx + 1), l)
    for (j in joints, idx in 1 to false) seq :
      JointExpSpec(nameit(`j, idx), j, default-limits, nameit(`l, idx - 1), nameit(`l, idx))
    ]
  println(res)
  res

defn nameit (side:Symbol, kind:Symbol, idx:Int) :
  if kind == `j and idx == 0 :
    `origin
  else :
    symbol-join $ [side "-" kind idx]

; val robot-simple-body-exp-spec5 =
;   KinematicsExpSpec(`bottom-j6,
;     cat-all $ [
;       robot-arm5(nameit{`left, _, _},   [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
;       robot-arm5(nameit{`right, _, _},  [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
;       robot-arm5(nameit{`bottom, _, _}, [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
;       [ JointExpSpec(`left-hip,  2, Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-l0, `left-l0)
;         JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-l0, `right-l0) ]
;       ] )

val robot-simple-body-exp-spec5 =
  KinematicsExpSpec(`bottom-j6,
  ; KinematicsExpSpec(`bottom-j5,
    cat-all $ [
      robot-arm5(nameit{`left, _, _},   [2.0f, 2.0f, 4.0f, 4.0f], [1, 2, 2])
      robot-arm5(nameit{`right, _, _},  [2.0f, 2.0f, 4.0f, 4.0f], [1, 2, 2])
      robot-arm5(nameit{`bottom, _, _}, [2.0f, 2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 2, 1])
      ; robot-arm5(nameit{`bottom, _, _}, [2.0f, 4.0f, 4.0f, 2.0f, 2.0f], [1, 2, 2, 1])
      [ JointExpSpec(`left-hip,  2, Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-l0, `left-l0)
        JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-l0, `right-l0) ]
      ] )

; val robot-simple-body-exp-spec5 = 
;   KinematicsExpSpec(`bottom-j2,
;     cat-all $ [
;       robot-arm5(nameit{`left, _, _}, [2.0f, 2.0f], [2])
;       robot-arm5(nameit{`right, _, _}, [2.0f, 2.0f], [2])
;       robot-arm5(nameit{`bottom, _, _}, [2.0f, 2.0f], [2])
;       [ JointExpSpec(`left-hip,  2, Box1f(-0.25f * PI-F, -0.25f * PI-F), `bottom-l0, `left-l0)
;         JointExpSpec(`right-hip, 2, Box1f( 0.25f * PI-F,  0.25f * PI-F), `bottom-l0, `right-l0) ]
;       ] )

; val robot-body-exp-spec =
;   KinematicsExpSpec(
;     `foot,
;     [LinkExpSpec(`ankle, `foot, `knee, 10.0f), LinkExpSpec(`thigh, `knee, `dick, 10.0f),
;      LinkExpSpec(`center-torso, `dick, `torso, 5.0f),
;      LinkExpSpec(`left-torso, `torso, `left-shoulder, 5.0f),
;      LinkExpSpec(`right-torso, `torso, `right-shoulder, 5.0f)
; 
;      LinkExpSpec(`left-upper-arm, `left-shoulder, `left-elbow, 10.0f), LinkExpSpec(`left-fore-arm, `left-elbow, `left-hand, 10.0f), ,
;      LinkExpSpec(`right-upper-arm, `right-shoulder, `right-elbow, 10.0f), LinkExpSpec(`right-fore-arm, `right-elbow, `right-hand, 10.0f),
;
;     [JointExpSpec(`left-elbow, 2, false, `left-upper-arm, `left-fore-arm)
;      JointExpSpec(`right-elbow, 2, false, `right-upper-arm, `right-fore-arm)
;      JointExpSpec(`knee, 2, false, `ankle, `thigh)
;      ])

defn set-costs (b:Body, pred:Cost -> True|False) :
  clear(costs(b))
  add-all(costs(b), filter(pred, all-costs(b)))
  for c in costs(b) do :
    println(name(c))
defn set-costs (b:Body, costs:Seqable<Symbol>) :
  set-costs(b, { contains?(costs, name(_)) })

public deftype DanceScheduler <: Scheduler
defn DanceScheduler (b:Body, make-sched:Body -> Seq<Phrase>, x-0:Float, x-1:Float) -> DanceScheduler :
  val state = SchedulerState()
  val sched = make-sched(b)
  new DanceScheduler :
    defmethod state (this) : state
    defmethod body (this) : b
    defmethod schedule (this) : sched

defn simple-sched (b:Body) -> Seq<Phrase> :
  repeatedly({ Phrase(1.0f) })

defn two-paths-sched (b:Body, x-0:Float, x-1:Float) -> Seq<Phrase> :
  val vtab = to-hashtable<Symbol,Vertex> $ for v in vertices(b) seq : name(v) => v
  val left-path  = vtab[`left-path]
  val right-path = vtab[`right-path]
  val base-costs = [ `main/base `main/basing `main/centering `main/limit `main/repel ]
  generate<Phrase> :
    var last-pt = V3f(0.0f, 0.0f, 0.0f)
    set-next(right-path, PointInterpolator(last-pt))
    while true :
      ; set-costs(b, cat(base-costs, [ `main/left-path `main/right-path ]))
      ; set-next(right-path, PointInterpolator(last-pt))
      ; val pt = rnd(dims-to-box $ xyz(x-0))
      ; println("LPOINT %_ %_" % [last-pt, pt])
      ; set-next(left-path, PointInterpolator(pt))
      ; yield(Phrase(2.0f))
      ; set-costs(b, cat(base-costs, [ `main/left-path `main/; touch ]))
      ; set-costs(b, cat(base-costs, [ `main/; touch ]))
      ; println("TOUCH")
      ; yield(Phrase(2.0f))
      ; last-pt = pt

      set-costs(b, cat(base-costs, [ `main/left-path `main/right-path ]))
      val pt = rnd(dims-to-box $ xyz(x-0)) + y3f(x-1)
      println("LPOINT %_" % [pt])
      set-next(left-path, PointInterpolator(pt))
      yield(Phrase(1.0f))
      set-costs(b, cat(base-costs, [ `main/left-path `main/right-path ]))
      set-next(right-path, PointInterpolator(pt))
      ; set-costs([ `main/touch ])
      println("RPOINT")
      yield(Phrase(1.0f))

      ; set-costs(b, cat(base-costs, [ `main/right-path ]))
      ; println("SQUARE")
      ; set-next(left-path, PolyLinePathInterpolator(mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f))
      ; yield(Phrase(4.0f))
      ; println("CUBE")
      ; set-next(left-path, PolyLinePathInterpolator(mov-y(x-1) $ mag(xyz(x-0)) $ cube-path, 4.0f))
      ; yield(Phrase(4.0f))

defn sigmoid (x:Float, t:Float) -> Float : 1.0f / (1.0f + exp(-1.0f * t * x))

defn fade-in (duration:Float, do-set-gain:Float -> False) -> Phrase :
  Phrase(duration, fn (t) : do-set-gain(sigmoid(20.0f * (t / duration - 0.5f), 0.5f)))

defn rnd-sched (b:Body, x-0:Float, x-1:Float) -> Seq<Phrase> :
  val vtab = to-hashtable<Symbol,Vertex> $ for v in vertices(b) seq : name(v) => v
  val base-costs = [ `main/base `main/basing `main/centering `main/limit `main/repel ]
  val symvar-tbl = to-hashtable<Symbol,SymVar> $ for v in symvars(b) seq : name(v) => v
  val target = symvar-tbl[`main/target]
  generate<Phrase> :
    set-costs(b, [ `main/base `main/basing `main/above ])
    yield(Phrase(2.0f))
    set-costs(b, [ `main/base `main/basing `main/above `main/centering `main/sphere `main/path ])
    yield(fade-in(8.0f, fn (nx) : (println(x(target)), set-x(target, 16.0f * nx))))
    set-costs(b, [ `main/base `main/basing `main/above ])
    yield(Phrase(4.0f))
    set-costs(b, [ `main/base `main/basing `main/above `main/centering `main/sphere `main/path ])
    yield(Phrase(100.0f))

defn one-path-sched (b:Body, right-joints:Tuple<Symbol>, orbit-particle:OrbitParticle, x-0:Float, x-1:Float) -> Seq<Phrase> :
  val vtab = to-hashtable<Symbol,Vertex> $ for v in vertices(b) seq : name(v) => v
  val left-path  = vtab[`left-path]
  val right-path = vtab[`right-path]
  val base-costs = [ `main/base `main/basing `main/centering `main/straighten `main/limit `main/repel ]
  val cost-tbl = to-hashtable<Symbol, Cost> $ for c in all-costs(b) seq : name(c) => c
  val centering-cost = cost-tbl[`main/centering]
  val straighten-cost = cost-tbl[`main/straighten]
  val left-path-cost = cost-tbl[`main/left-path]
  val right-path-cost = cost-tbl[`main/right-path]
  val fall-left-cost = cost-tbl[`main/fall-left]
  val fall-right-cost = cost-tbl[`main/fall-right]
  val fall-cost = cost-tbl[`main/fall]
  val on-line-right-cost = cost-tbl[`main/on-line-right]
  val above-cost = cost-tbl[`main/above]
  ; val touch-costs = to-tuple $ for j in right-joints seq : symbol-join([`main "/" `touch "/" j])
  generate<Phrase> :
    set-costs(b, [ `main/base `main/basing `main/above ])
    yield(Phrase(2.0f))
    set-costs(b, [ `main/base `main/basing `main/above `main/straighten ])
    yield(fade-in(6.0f, set-gain{straighten-cost, _}))
    set-costs(b, [ `main/base `main/basing `main/above `main/fall ])
    yield(fade-in(6.0f, set-gain{fall-cost, _}))
    set-costs(b, [ `main/base `main/basing `main/above `main/straighten ])
    yield(fade-in(6.0f, set-gain{straighten-cost, _}))
    ; for c in touch-costs do :
    ;   set-costs(b, [ `main/base `main/basing `main/above c ])
    ;   yield(Phrase(2.0f))
    ; set-costs(b, [ `main/base `main/basing, `main/fall ])
    ; yield(Phrase(4.0f))
    ; set-gain(fall-cost, 10.0f)
    ; set-next(left-path, PointInterpolator(V3f(-4.0f, -8.0f, 0.0f)))
    ; set-next(right-path, PointInterpolator(V3f(4.0f, -8.0f, 0.0f)))
    ; set-costs(b, [ `main/base `main/basing `main/above `main/left-path `main/right-path ])
    ; yield(fade-in(4.0f, fn (g) : (set-gain(left-path-cost, g), set-gain(right-path-cost, g))))
    ; set-costs(b, [ `main/base `main/basing, `main/straighten ])
    ; yield(Phrase(2.0f))
    
    set-next(left-path, interpolator-of(set-params(orbit-particle, xyz(0.0f), x-0, 1.0f)))
    set-next(right-path, PointInterpolator(V3f(4.0f, 8.0f, 0.0f)))
    set-costs(b, [ `main/base `main/basing, `main/limit `main/repel `main/above `main/left-path `main/right-path ])
    yield(fade-in(4.0f, set-gain{left-path-cost, _}))
    yield(Phrase(4.0f))

    set-costs(b, [ `main/base `main/basing, `main/limit `main/repel `main/above `main/left-path `main/on-line-right ])
    yield(fade-in(4.0f, set-gain{on-line-right-cost, _}))
    yield(Phrase(4.0f))

    set-costs(b, [ `main/base `main/basing, `main/limit `main/repel `main/above `main/left-path `main/fall-right ])
    yield(fade-in(4.0f, set-gain{left-path-cost, _}))
    yield(Phrase(4.0f))

    set-costs(b, [ `main/base `main/basing `main/straighten ])
    yield(Phrase(2.0f))

    set-next(left-path, interpolator-of(set-params(orbit-particle, xyz(0.0f), x-0, 1.0f)))
    set-costs(b, [ `main/base `main/basing `main/limit `main/repel `main/above `main/centering `main/left-path ])
    yield(fade-in(4.0f, set-gain{left-path-cost, _}))
    yield(Phrase(4.0f))
    set-costs(b, [ `main/base `main/basing `main/above `main/repel `main/straighten ])
    yield(Phrase(2.0f))
    set-costs(b, base-costs)
    while true :
      yield(Phrase(1.0f))

defn demo (top-name:String, n-0:Int, n-1:Int, n-2:Int, x-0:Float, x-1:Float, x-2:Float) :
  val time = SymVar(`time, 0.0f, false, false)
  var sched : Body -> Seq<Phrase> = simple-sched
  val m =
    switch(top-name) :
      "robot-arm0" : KinematicsBody(`main, robot-arm-spec0)
      "robot-arm" : KinematicsBody(`main, robot-arm-spec)
      "robot-arm-exp" : KinematicsExpBody(`main, robot-arm-exp-spec)
      "robot-arm-exp2" : KinematicsExpBody(`main, robot-arm-exp-spec2)
      "robot-arm-exp3" : KinematicsExpBody(`main, robot-arm-exp-spec3)
      "open-manipulator-x" : KinematicsExpBody(`main, open-manipulator-x-spec)
      "simple-robot-exp" : KinematicsExpBody(`main, robot-simple-body-exp-spec)
      "simple-robot-exp2" : KinematicsExpBody(`main, robot-simple-body-exp-spec2)
      "robot-leg-arm" : KinematicsExpBody(`main, robot-leg-arm-exp-spec)
      "robot-leg" : KinematicsBody(`main, robot-leg-spec)
      "kinematics" : KinematicsExpBody2(`main)
      ; "time-kinematics" : TimeKinematics(`main, x-0, time)
      ; "time-exp-kinematics" : TimeExpKinematics(`main, x-0, time, robot-arm-exp-spec3, `finger)
      ; "time-exp-kinematics-real" : TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec2, `right-tip)
      ; "time-exp-kinematics-real3" : TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec3, `right-finger)
      ; "time-exp-kinematics-real4" : TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec4, `right-tip)
      "time-dancer-two-paths" :
        sched = two-paths-sched{_, x-0, x-1}
        val left-path  = PolyLinePath(`left-path,  mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        val right-path = PolyLinePath(`right-path, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-simple-path" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        TimeExpKinematicsSimplePath(`main, time, robot-arm-exp-spec, path, `hand)
      "time-dancer-square" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
        TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-cube" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(x-0)) $ cube-path, 8.0f)
        TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-uing" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPath(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-two-rnds" :
        val left-path = OrbitParticle(`left-particle, V3f(-8.0f, x-1, 5.0f), x-0, 0.5f)
        val right-path = OrbitParticle(`right-particle, V3f(8.0f, x-1, 5.0f), x-0, 1.0f)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-two-orbit2s" :
        val left-path = Orbit2Particle(`left-particle, y3f(x-1), x-0, x-1, 0.25f, 1.0f)
        val right-path = Orbit2Particle(`right-particle, y3f(x-1), x-0, x-1, 0.25f, 1.0f)
        TimeExpKinematicsTwoPaths(`main, x-0, time, robot-simple-body-exp-spec5, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-rnd" :
        val path = OrbitParticle(`particle, y3f(x-1), x-0, 1.0f)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        ; sched = rnd-sched{_, x-0, x-1}
        TimeExpKinematicsPathCenter(`main, x-0, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-rnd-orbit2" :
        val path = Orbit2Particle(`particle, y3f(x-1), x-0, x-1, 0.25f, 1.0f)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        TimeExpKinematicsPathCenter(`main, x-0, time, robot-simple-body-exp-spec5,
          `origin, bottom-joints, left-joints, right-joints, path, `left-j4, `right-j4)
      "time-dancer-one-path" :
        val left-path = OrbitParticle(`left-path, y3f(x-1), x-0, 1.0f)
        val path-speed = SymVar(`path-speed, 1.0f, false, false)
        val right-path = PolyLinePath(`right-path, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 1.0f)
        val left-joints = [`left-j4, `left-j3, `left-j2, `left-j1]
        val right-joints = [`right-j4, `right-j3, `right-j2, `right-j1]
        val bottom-joints = [`bottom-j4 `bottom-j3 `bottom-j2 `bottom-j1]
        sched = one-path-sched{_, right-joints, left-path, x-0, x-1}
        TimeExpKinematicsPathCenterStraighten(`main, x-0, time, robot-simple-body-exp-spec5,
           bottom-joints, left-joints, right-joints, left-path, `left-j4, right-path, `right-j4)
      "time-dancer-rnd-base" :
        val path = OrbitParticle(`particle, y3f(x-1), x-0, 1.0f)
        TimeExpKinematicsPathCenterBase(`main, x-0, x-2, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-rnd-sphere" :
        val path = OrbitParticle(`particle, y3f(x-1), 5.0f,  0.25f)
        TimeExpKinematicsPathSphere(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j2, `left-j4, `right-j4)
      ; "time-dancer-curl" :
      ;   TimeExpKinematicsCurl(`main, x-0, time, robot-simple-body-exp-spec5)
      ; "time-dancer-seq" :
      ;   val path1 = PolyLinePath(`path1, mov-y(x-1) $ mag(xyz(x-0)) $ square-path, 4.0f)
      ;   val path2 = PolyLinePath(`path2, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 6.0f)
      ;   val paths = [20.0f => path1, 20.0f => path2]
      ;   TimeExpKinematicsPaths(`main, x-0, time, robot-simple-body-exp-spec5, paths, `right-j4)
      "time-dancer-uing-wrist" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPathWrist(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4, `right-l3)
      "time-dancer-uing-straight" :
        val path = PolyLinePath(`path, mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPathStraight(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4, `right)
      "time-dancer-uing-straighten" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(x-0)) $ round-you, 8.0f)
        TimeExpKinematicsPathStraighten(`main, x-0, time, robot-simple-body-exp-spec5, path, `right-j4)
      "time-dancer-uing-mirror" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(2.0f * x-0)) $ round-you, 16.0f)
        TimeExpKinematicsMirror(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-uing-reflect" :
        val path = PolyLinePath(`path, mov-y(x-1) $ mag(xyz(2.0f * x-0)) $ round-you, 16.0f)
        TimeExpKinematicsReflect(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-uing-circle" :
        val path = PolyLinePath(`path, mov-z(2.0f) $ mov-y(x-1) $ mag(xyz(2.0f * x-0)) $ round-you, 16.0f)
        TimeExpKinematicsCircle(`main, x-0, time, robot-simple-body-exp-spec5, path, `left-j4, `right-j4)
      "time-dancer-bounce" :
        TimeExpKinematicsBounce(`main, x-0, time, robot-simple-body-exp-spec5, `left-j4, `right-j4)
      ; "time-leg" : TimeLeg(`main, x-0, time)
      else : LineBody(`line, 7.0f)

  ; println("RUNNING MODULE...")

  run-module(m, time, DanceScheduler{_, sched, x-0, x-1})  

defn demo (top-name:String) :
  demo(top-name, top-n-0, top-n-1, top-n-2, top-x-0, top-x-1, top-x-2)

defn main () :
  parse-args(screen-props, command-line-arguments())
  RANDOM = Random(current-time-us() when (top-seed < 0) else to-long(top-seed))
  demo(top-name)  

main()

